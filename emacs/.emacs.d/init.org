#+TITLE: Emacs configuration file
#+AUTHOR: Matthew Jones
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle yes
#+PROPERTY: header-args:elisp :lexical t

* Configurations
** Lexical binding

I want lexical scoping for the init-file, which can be specified in the
header. The first line of the configuration is as follows:

#+BEGIN_SRC emacs-lisp
  ;;; -*- lexical-binding: t -*-
#+END_SRC

#+begin_src emacs-lisp :tangle "early-init.el"
  ;;; -*- lexical-binding: t -*-
#+end_src

** Auto-tangling

The =init.el= should (after the first run) mirror the source blocks in
the =init.org=. We can use =C-c C-v t= to run =org-babel-tangle=, which
extracts the code blocks from the current file into a source-specific
file (in this case a =.el=-file).

To avoid doing this each time a change is made we can add a function to
the =after-save-hook= ensuring to always tangle and byte-compile the
=org=-document after changes.

#+BEGIN_SRC emacs-lisp
  (defun tangle-init ()
    "If the current buffer is 'init.org' the code-blocks are
  tangled, and the tangled file is compiled."
    (when (or (equal (buffer-file-name)
                     (expand-file-name (concat user-emacs-directory "init.org")))
              (equal (buffer-file-name)
                     (expand-file-name (concat user-emacs-directory "private.org"))))
      ;; Avoid running hooks when tangling.
      (let ((prog-mode-hook nil))
        (org-babel-tangle))))

  (add-hook 'after-save-hook 'tangle-init)
#+END_SRC

* early-init

#+begin_src emacs-lisp :tangle "early-init.el"
  ;; Defer garbage collection further back in the startup process
  (setq gc-cons-threshold most-positive-fixnum)

  (set-language-environment "UTF-8")
  (setq default-input-method nil
        load-prefer-newer t
        ns-use-thin-smoothing t
        ns-use-proxy-icon nil
        tab-bar-show nil
        frame-title-format "%b - emacs"
        frame-resize-pixelwise t
        window-resize-pixelwise t
        default-frame-alist `((ns-transparent-titlebar . t)
                              (width . 170)
                              (height . 50)))

  ;; Prevent the glimpse of un-styled Emacs by disabling these UI elements early.
  (push '(menu-bar-lines . 0) default-frame-alist)
  (push '(tool-bar-lines . 0) default-frame-alist)
  (push '(vertical-scroll-bars) default-frame-alist)
  (push '(horizontal-scroll-bars) default-frame-alist)
  (push '(internal-border-width . 0) default-frame-alist)

  (setq tool-bar-mode nil
        scroll-bar-mode nil)
  (when (bound-and-true-p tooltip-mode)
    (tooltip-mode -1))

  (setq use-file-dialog nil)
  (setq use-dialog-box nil)

  (unless (memq window-system '(mac ns))
    ;; (menu-bar-mode -1)
    (setq menu-bar-mode nil))

  (when (fboundp 'horizontal-scroll-bar-mode)
    (horizontal-scroll-bar-mode -1))
  ;; Resizing the Emacs frame can be a terribly expensive part of changing the
  ;; font. By inhibiting this, we easily halve startup times with fonts that are
  ;; larger than the system default.
  (setq frame-inhibit-implied-resize t)

  (setq auto-mode-case-fold nil)

  ;; Disable bidirectional text scanning for a modest performance boost.
  (setq-default bidi-display-reordering 'left-to-right
                bidi-paragraph-direction 'left-to-right)

  ;; Give up some bidirectional functionality for slightly faster re-display.
  (setq bidi-inhibit-bpa t)

  ;; Ignore X resources; its settings would be redundant with the other settings
  ;; in this file and can conflict with later config (particularly where the
  ;; cursor color is concerned).
  (advice-add #'x-apply-session-resources :override #'ignore)

  (setq comp-deferred-compilation-deny-list ".*")
  (setq native-comp-deferred-compilation nil
        native-comp-async-report-warnings-errors nil)
  (setq package-enable-at-startup t)
#+end_src

* Straight.el

** bootstrap

#+BEGIN_SRC emacs-lisp
  (setq straight-repository-branch "develop")
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 6))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
#+END_SRC

** startup

#+begin_src emacs-lisp :tangle "early-init.el"
  (setq straight-check-for-modifications '(find-when-checking check-on-save))
#+end_src

** use-package

#+BEGIN_SRC emacs-lisp
  (straight-use-package 'use-package)
  (setq straight-use-package-by-default t)
  (setq use-package-verbose t)
#+END_SRC

** Package management

#+begin_src emacs-lisp
  (defun nuance/update-versions ()
    (interactive)
    (straight-pull-all))

  (defun nuance/native-compile ()
    (interactive)
    (when (featurep 'native-compile)
      (let
          ((native-comp-deferred-compilation t)
           (native-comp-async-jobs-number (cl-parse-integer (s-trim (shell-command-to-string "getconf _NPROCESSORS_ONLN")))))
        (native-compile-async "~/.emacs.d/straight/build" 'recursively)
        (while comp-files-queue
          (progn (message "comp-files-queue: %s" (and comp-files-queue (length comp-files-queue)))
                 (sleep-for 1))))))
#+end_src

* Performance optimizations

Mostly adapted from [[https://github.com/zzamboni/dot-emacs/blob/master/init.org#performance-optimization][dot-emacs/init.org at master Â· zzamboni/dot-emacs]]

** Disable file handlers

#+BEGIN_SRC emacs-lisp
  (setq
   nuance/file-name-handler-alist file-name-handler-alist
   file-name-handler-alist nil)
  (add-hook 'after-init-hook (lambda () (setq file-name-handler-alist nuance/file-name-handler-alist)))
#+END_SRC

** Report startup performance

#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-startup-hook
            (lambda ()
              (message "Emacs ready in %s with %d garbage collections."
                       (emacs-init-time "%.2f seconds")
                       gcs-done)))
#+END_SRC

** Increase read process output buffer size

#+begin_src emacs-lisp
  (setq read-process-output-max (* 1024 1024)) ;; 1mb
#+end_src

** Cache SSL lookups

#+BEGIN_SRC emacs-lisp
  (customize-set-variable 'nsm-settings-file (concat user-emacs-directory "network-security.data"))
#+END_SRC

** Clean up old buffers

#+begin_src emacs-lisp
  (midnight-mode t)
#+end_src

* Disable nswin keybindings
I don't really want all the default super bindings (I'd prefer a simpler emacs experience).

#+BEGIN_SRC emacs-lisp
  (custom-set-variables
   '(mac-command-modifier (quote super))
   '(mac-option-modifier (quote meta))
   '(mac-pass-command-to-system nil)
   '(mac-pass-control-to-system nil))

  (map-keymap
   (lambda (event binding)
     (let ((key-desc (key-description (vector event))))
       (when (string-match-p "\\bs-" key-desc)
         (global-unset-key (vector event)))))
   global-map)
#+END_SRC

* Niceities
** File I/O

#+BEGIN_SRC emacs-lisp
  (set-language-environment "UTF-8")
  (set-default-coding-systems 'utf-8)

  (setq save-place-file (concat user-emacs-directory "places")
        backup-directory-alist `(("." . ,(concat user-emacs-directory "backups")))
        backup-inhibited t
        sentence-end-double-space nil       ; No double space
        vc-follow-symlinks nil)
#+END_SRC

** Disable custom

#+BEGIN_SRC emacs-lisp
  (setq custom-file (make-temp-file ""))   ; Discard customization's
#+END_SRC

** Load environment variables

#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :custom ((exec-path-from-shell-variables '("PATH" "MANPATH" "SSH_AUTH_SOCK")))
    :config (exec-path-from-shell-initialize))
#+END_SRC

** Elisp helpers

#+BEGIN_SRC emacs-lisp
  ;; functional helpers
  (use-package dash)

  ;; string manipulation
  (use-package s)

  ;; filepath manipulation
  (use-package f)

  (use-package compat)
#+END_SRC

** Encrypted authinfo

#+begin_src emacs-lisp
  (setq auth-sources '((:source "~/.authinfo.gpg")))
#+end_src

** so-long

#+begin_src emacs-lisp
  (use-package so-long
    :config (global-so-long-mode 1)
    ;; Force so-long to be on in compilation buffers
    :hook (compilation-mode . so-long-minor-mode))
#+end_src

** Confirm exit

#+begin_src emacs-lisp
  (setq confirm-kill-emacs 'yes-or-no-p)
#+end_src

** FFAP

#+begin_src emacs-lisp
  (setq ffap-machine-p-known 'reject)
  (ffap-bindings)
#+end_src

** Restore state between relaunches

#+begin_src emacs-lisp
  (setq savehist-save-minibuffer-history nil)
  (savehist-mode 1)
  (add-to-list 'savehist-additional-variables 'compile-command)
  (add-to-list 'savehist-additional-variables 'xref--history)

  (recentf-mode 1)
  (save-place-mode 1)
#+end_src

** Kill / yank

#+begin_src emacs-lisp
  (customize-set-variable 'kill-do-not-save-duplicates t)
  ;; raycast will send s-v to trigger a paste
  (global-set-key (kbd "s-v") 'yank)
#+end_src

** Executable bit

#+begin_src emacs-lisp
  (add-hook 'after-save-hook #'executable-make-buffer-file-executable-if-script-p)
#+end_src

** Buffer Rules

Largely based on [[https://www.masteringemacs.org/article/demystifying-emacs-window-manager][Mastering Emacs - Demystifying Emacs's Window Manager]]

#+begin_src emacs-lisp
  (setq switch-to-buffer-obey-display-actions nil)
  (setq switch-to-buffer-in-dedicated-window 'pop)
  (setq window-sides-slots '(1 1 1 1))
  (global-set-key (kbd "C-x !") 'window-toggle-side-windows)
  (global-set-key (kbd "<f1>") 'window-toggle-side-windows)
  (global-set-key (kbd "<f2>") 'balance-windows)

  (defun nuance/display-buffer-in-minor-drawer (buffer-name)
    (add-to-list 'display-buffer-alist
                 `(,buffer-name (display-buffer-reuse-window display-buffer-in-side-window)
                                (side . right)
                                (slot . 0)
                                (window-parameters . ((no-delete-other-windows . t)))
                                (window-height . 25)
                                (window-width . 80)
                                (window-min-width . 80)
                                (preserve-size . (nil . t)))))
#+end_src

*** Compilation buffer on bottom

#+begin_src emacs-lisp
  (nuance/display-buffer-in-minor-drawer "*compilation*")
  (nuance/display-buffer-in-minor-drawer "*detached-compilation*")
  (nuance/display-buffer-in-minor-drawer "*Messages*")
#+end_src

* UI Appearance
** UI Interaction

#+BEGIN_SRC emacs-lisp
  (if (boundp 'use-short-answers)
      (setq use-short-answers t)
    (advice-add 'yes-or-no-p :override #'y-or-n-p))
  (setq apropos-do-all t
        echo-keystrokes 0.1               ; Show keystrokes asap
        inhibit-startup-message t         ; No splash screen please
        initial-scratch-message nil       ; Clean scratch buffer
        initial-major-mode 'emacs-lisp-mode)
#+END_SRC

** Bell

#+BEGIN_SRC emacs-lisp
  (setq visible-bell t
        inhibit-startup-echo-area-message t)

  (use-package mode-line-bell
    :demand t
    :config (mode-line-bell-mode))
#+END_SRC

** Cursor

#+BEGIN_SRC emacs-lisp
  (setq cursor-type 'hbar)
  (blink-cursor-mode 0)
#+END_SRC

** Scrolling

#+begin_src emacs-lisp
  (unless (eq (window-system) 'mac)
    (if (boundp 'pixel-scroll-precision-mode)
        (pixel-scroll-precision-mode 1)))
#+end_src

** Highlight line
#+begin_src emacs-lisp
  (global-hl-line-mode t)
  (defun pulse-line (&rest _)
    "Pulse the current line."
    (pulse-momentary-highlight-one-line (point)))

  (dolist (command '(scroll-up-command scroll-down-command recenter-top-bottom other-window))
    (advice-add command :after #'pulse-line))
#+end_src

** Line spacing

#+begin_src emacs-lisp
  (setq line-spacing 0.1)
#+end_src

** Minimal UI

#+BEGIN_SRC emacs-lisp
  (if (boundp 'toggle-frame-fullscreen) (toggle-frame-fullscreen))
  (if (boundp 'scroll-bar-mode) (scroll-bar-mode 0))
#+END_SRC

** Mode-line

Minimal mode-line.

#+begin_src emacs-lisp
  (use-package mood-line :hook (after-init . mood-line-mode)
    :custom (mood-line-format
             '((" "
                (mood-line-segment-buffer-status)
                " "
                (mood-line-segment-buffer-name)
                " "
                (if-let ((c (mood-line-segment-anzu)))
                    (concat c " "))
                (if-let ((c (mood-line-segment-multiple-cursors)))
                    (concat c " "))
                (mood-line-segment-cursor-position)
                " "
                (mood-line-segment-scroll)
                "")
               ((mood-line-segment-major-mode)
                " "
                (mood-line-segment-misc-info)
                " "
                (mood-line-segment-process)
                " "))))
#+end_src

Show isearch hit information in mode-line.

#+begin_src emacs-lisp
  (use-package anzu :config (global-anzu-mode t))
#+end_src

*** Mode-Line Buffer Name

#+begin_src emacs-lisp
  (use-package shrink-path
    :after mood-line
    :config

    (defun nuance/project-relative-shrunk-path (project path)
      (if (f-ancestor-of? (project-root project) path)
          (let*
              ((shrunk-path (split-string (shrink-path-file path) "/"))
               (project-root-size (length (split-string (project-root project) "/"))))
            (string-join (-slice shrunk-path project-root-size) "/"))
        (shrink-path-file path)))

    (defun nuance/buffer-name ()
      (cond
       ((and (project-current) (buffer-file-name)) (format "[%s] %s" (project-name (project-current)) (nuance/project-relative-shrunk-path (project-current) (buffer-file-name))))
       ((buffer-file-name) (shrink-path-file (buffer-file-name)))
       (t (buffer-name))))

    (defvar-local nuance/buffer-name--cache nil)
    (defun mood-line-segment-buffer-name ()
      (unless nuance/buffer-name--cache
        (set-variable 'nuance/buffer-name--cache (format "%s  " (nuance/buffer-name))))
      (propertize nuance/buffer-name--cache 'face 'mood-line-buffer-name)))
#+end_src

** Line numbering

#+begin_src emacs-lisp
  (use-package prog-mode
    :straight nil
    :custom ((display-line-numbers-width t))
    :hook ('prog-mode . #'display-line-numbers-mode))
#+end_src

** Rainbow delimiters

#+begin_src emacs-lisp
  (use-package rainbow-delimiters :hook (prog-mode . rainbow-delimiters-mode))
#+end_src

** Matching parens highlight

#+BEGIN_SRC emacs-lisp
  (show-paren-mode)
#+END_SRC

** Terminal Title

#+begin_src emacs-lisp
  (defun nuance/osc-command (code body)
    (when (not (or noninteractive (window-system)))
      (let ((cmd (concat "\033]" code  ";" body "\007")))
        (send-string-to-terminal cmd))))

  (defun nuance/xterm-title-update ()
    (nuance/osc-command "2" (format-mode-line frame-title-format)))

  (defun nuance/xterm-bg-update (color)
    (nuance/osc-command "11" color))

  (add-hook 'post-command-hook 'nuance/xterm-title-update)
#+end_src

** Light / Dark theme toggle
I'd like to toggle between light & dark themes.

#+BEGIN_SRC emacs-lisp
  (use-package doom-themes
    :config
    (defvar light-theme 'doom-solarized-light)
    (defvar dark-theme 'doom-rouge)

    (defvar nuance/current-theme 'light)
    (add-to-list 'savehist-additional-variables 'nuance/current-theme)

    (defun nuance/apply-theme (appearance)
      "Load theme, taking current system APPEARANCE into consideration."
      (mapc #'disable-theme custom-enabled-themes)
      (pcase appearance
        ('light (load-theme light-theme t) (nuance/xterm-bg-update "#ffffff"))
        ('dark (load-theme dark-theme t) (nuance/xterm-bg-update "#010000"))))

    (defun dark () (interactive) (setq nuance/current-theme 'dark) (nuance/apply-theme 'dark))
    (defun light () (interactive) (setq nuance/current-theme 'light) (nuance/apply-theme 'light))

    (add-hook 'ns-system-appearance-change-functions #'nuance/apply-theme)
    (nuance/apply-theme 'dark)
    :hook
    (mac-effective-appearance-change
     . (lambda ()
         (nuance/apply-theme
          (pcase (plist-get (mac-application-state) :appearance)
            ("NSAppearanceNameDarkAqua" 'dark)
            ("NSAppearanceNameAqua" 'light))))))
#+END_SRC

*** Solaire

#+begin_src emacs-lisp
  (use-package solaire-mode
    :config (solaire-global-mode))
#+end_src

** Fonts

#+BEGIN_SRC emacs-lisp
  (setq nuance/font-size 100)

  (set-face-attribute 'default nil
                      :family "IBM Plex Mono"
                      :height nuance/font-size)
  (set-face-attribute 'fixed-pitch nil
                      :family "IBM Plex Mono")
  (set-face-attribute 'variable-pitch nil
                      :family "IBM Plex Sans")

  (set-face-attribute 'mode-line nil :height nuance/font-size)
  (set-face-attribute 'mode-line-inactive nil :height nuance/font-size);

  (use-package all-the-icons :if (display-graphic-p))
#+END_SRC

** Set titlebar color

#+BEGIN_SRC emacs-lisp
  (use-package ns-auto-titlebar
    :if (eq system-type 'darwin)
    :config
    (ns-auto-titlebar-mode))
#+END_SRC

** Mixed pitch

#+begin_src emacs-lisp
  (use-package mixed-pitch
    :hook (text-mode . mixed-pitch-mode))
#+end_src

* UI Interaction
** Helpers

#+begin_src emacs-lisp
  (defun dwim-default-text ()
    ;; Find a good default value for prompts
    (if (region-active-p) (buffer-substring (region-beginning) (region-end)) (thing-at-point 'symbol)))
#+end_src

** Minibuffer

#+begin_src emacs-lisp
  (setq nuance/completion-candidates 25)
#+end_src

*** Orderless

#+begin_src emacs-lisp
  (use-package orderless
    :init
    (setq completion-styles '(orderless)
          orderless-matching-styles '(orderless-prefixes)
          completion-category-defaults nil
          completion-category-overrides
          '((file (styles orderless))
            (consult-xref (styles orderless))
            (nuance/dynamic (styles . (basic)))
            (nuance/dynamic-file (styles . (basic))))))
#+end_src

*** Vertico

#+begin_src emacs-lisp
  (use-package vertico
    :straight (vertico :files (:defaults "extensions/*")
                       :includes (vertico-buffer vertico-directory))
    :init
    (vertico-mode)
    (unless (window-system) (vertico-buffer-mode))
    :custom
    (vertico-count nuance/completion-candidates)
    (vertico-resize t)
    (vertico-cycle t)
    (vertico-buffer-display-action '(display-buffer-in-side-window (window-height . 12) (side . top))))

  ;; A few more useful configurations...
  (use-package emacs
    :init
    ;; Do not allow the cursor in the minibuffer prompt
    (setq minibuffer-prompt-properties
          '(read-only t cursor-intangible t face minibuffer-prompt))
    (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

    ;; Emacs 28: Hide commands in M-x which do not work in the current mode.
    ;; Vertico commands are hidden in normal buffers.
    (setq read-extended-command-predicate #'command-completion-default-include-p)

    ;; Enable recursive minibuffers
    (setq enable-recursive-minibuffers t))
#+end_src

**** posframe

#+begin_src emacs-lisp
  (use-package vertico-posframe
    :config
    (vertico-posframe-mode 1)
    ;;    (defun cleanup-non-posframe (&optional frame) (unless (string-equal "posframe" (frame-parameter frame 'title)) (message "cleanup vertico frame %s" (frame-parameters frame)) (vertico-posframe-cleanup)))
    ;;    (add-hook 'window-size-change-functions #'cleanup-non-posframe)
    :custom
    (vertico-posframe-font "IBM Plex Mono 13")
    :custom-face
    (marginalia-documentation ((t (:inherit font-lock-doc-face :family "IBM Plex Sans")))))
#+end_src

*** Consult

#+begin_src emacs-lisp
  (use-package consult
    :demand t

    :bind (("s-o" . (lambda () (interactive) (consult-line (dwim-default-text))))
           ("s-i" . consult-imenu)
           ("s-O" . consult-imenu-multi)
           ("s-l" . consult-goto-line)
           ("s-t" . consult-buffer)
           ("M-y" . consult-yank-pop)
           ("<help> a" . consult-apropos))
    :custom ((consult-async-input-throttle 0.05)
             (consult-async-input-debounce 0.1)
             (consult-project-function nil))
    :init
    (fset 'multi-occur #'consult-multi-occur)
    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref))
#+end_src

*** Marginalia

#+begin_src emacs-lisp
  (use-package marginalia
    :custom (marginalias-max-relative-age 0) (marginalia-align 'right)
    :config
    (marginalia-mode)
    (setq marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light))
    (add-to-list 'marginalia-annotator-registry '(nuance/dynamic-file marginalia-annotate-file)))
#+end_src

*** All-the-icons-completion

#+begin_src emacs-lisp
  (use-package all-the-icons-completion
    :after (marginalia all-the-icons)
    :hook (marginalia-mode . all-the-icons-completion-marginalia-setup)
    :init
    (all-the-icons-completion-mode))
#+end_src

*** Embark

#+begin_src emacs-lisp
  (use-package embark
    :init (setq prefix-help-command #'embark-prefix-help-command)
    :bind
    ("C-." . embark-act)
    ("C-;" . embark-dwim)
    ("C-h b" . embark-bindings)
    ;; DWIM inside the minibuffer is pretty much always export
    (:map minibuffer-local-map ("C-;" . embark-export)))

  (use-package embark-consult
    :hook
    (embark-collect-mode . consult-preview-at-point-mode))
#+end_src

*** Dynamic completion helper

#+begin_src emacs-lisp
  (defun nuance/complete-dynamic (results-fn &optional category)
    "Construct a completion table with results from results-fn"
    (lambda (string predicate action)
      (pcase action
        (`(boundaries . ,suffix) `(boundaries . (0 . 0)))
        ('metadata `(metadata (category . ,(if category category 'nuance/dynamic))))
        (_ (apply results-fn (list string))))))
#+end_src

** Completion

*** Corfu

#+BEGIN_SRC emacs-lisp
  (use-package corfu
    :straight (corfu :files (:defaults "extensions/*")
                     :includes (corfu-popupinfo))
    :bind (:map corfu-map
                ("C-n" . corfu-next)
                ("C-p" . corfu-previous)
                ("<escape>" . corfu-quit)
                ("<return>" . corfu-insert)
                ("<tab>" . corfu-insert)
                ("SPC" . corfu-insert-separator)
                ("M-d" . corfu-popupinfo-toggle)
                ("C-g" . corfu-quit)
                ("M-l" . corfu-show-location)
                ("M-;" . corfu-move-to-minibuffer)
                ;; Scroll in the documentation window
                ("M-n" . corfu-popupinfo-scroll-up)
                ("M-p" . corfu-popupinfo-scroll-down))
    :custom
    ;; Works with `indent-for-tab-command'. Make sure tab doesn't indent when you
    ;; want to perform completion
    (tab-always-indent 'complete)
    (c-tab-always-indent 'complete)
    (completion-cycle-threshold nil)      ; Always show candidates in menu

    (corfu-auto t)
    (corfu-auto-prefix 0)
    (corfu-auto-delay 0)

    (corfu-min-width 80)
    (corfu-max-width 160)     ; Always have the same width
    (corfu-count 28)
    (corfu-scroll-margin 4)
    (corfu-cycle nil)

    (corfu-echo-documentation nil)        ; Already use corfu-doc
    (corfu-separator ?\s)                 ; Necessary for use with orderless
    (corfu-quit-no-match 'separator)

    (corfu-preview-current 'insert)       ; Preview current candidate?
    (corfu-preselect-first t)             ; Preselect first candidate?
    (corfu-popupinfo-delay 0.5)
    (corfu-popupinfo-max-width 70)
    (corfu-popupinfo-max-height 20)

    :init
    (global-corfu-mode)
    :config

    (defun corfu-move-to-minibuffer ()
      (interactive)
      (let ((completion-extra-properties corfu--extra)
            completion-cycle-threshold completion-cycling)
        (apply #'consult-completion-in-region completion-in-region--data)))

    ;; Enable Corfu more generally for every minibuffer, as long as no other
    ;; completion UI is active. If you use Mct or Vertico as your main minibuffer
    ;; completion UI. From
    ;; https://github.com/minad/corfu#completing-with-corfu-in-the-minibuffer
    (defun corfu-enable-always-in-minibuffer ()
      "Enable Corfu in the minibuffer if Vertico/Mct are not active."
      (unless (bound-and-true-p vertico--input)
        (setq-local corfu-auto nil)       ; Ensure auto completion is disabled
        (corfu-mode 1)))
    :hook ((minibuffer-setup . corfu-enable-always-in-minibuffer)
           (corfu-mode . corfu-popupinfo-mode)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package cape)
#+END_SRC

*** Kind icon

#+begin_src emacs-lisp
  (use-package kind-icon
    :demand t
    :custom
    (kind-icon-use-icons t)
    (kind-icon-default-face 'corfu-default) ; Have background color be the same as `corfu' face background
    (kind-icon-blend-background nil)  ; Use midpoint color between foreground and background colors ("blended")?
    (kind-icon-blend-frac 0.08)

    :config
    (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter) ; Enable `kind-icon'

    :hook (nuance/after-theme-change . kind-icon-reset-cache))
#+end_src

** Default to regexp search

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :bind (("C-s" . 'isearch-forward-regexp)
           ("C-r" . 'isearch-backward-regexp)))
#+END_SRC

** Sublime-like
*** Don't create random files

#+begin_src emacs-lisp
  (setq make-backup-files nil
        auto-save-default nil)
#+end_src

*** Automatically add newlines at EOF
#+BEGIN_SRC emacs-lisp
  (setq require-final-newline t)
#+END_SRC

*** Disable tab indentation

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
#+END_SRC

*** Remove trailing whitespace

#+BEGIN_SRC emacs-lisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

*** Expand region

#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :bind (("s-h" . 'er/expand-region)
           ("s-H" . 'er/contract-region)))
#+END_SRC

*** Multiple cursors

#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :custom ((mc/always-run-for-all t) (hum/lines-to-expand 2))
    :config
    (add-to-list 'mc/unsupported-minor-modes 'eldoc-mode)

    (defun nuance/mark-next-like-this-symbol (arg)
      (interactive "p")
      (if (region-active-p)
          (mc/mark-next-like-this arg)
        (mc--select-thing-at-point 'symbol)))
    (add-to-list 'mc--default-cmds-to-run-once 'nuance/mark-next-like-this-symbol)

    :bind (("s-L" . mc/edit-lines)
           ("C-c L" . mc/edit-lines)
           ("s-d" . nuance/mark-next-like-this-symbol)
           ("C-c d" . nuance/mark-next-like-this-symbol)
           ("s-D" . mc/mark-all-dwim)
           ("C-c D" . mc/mark-all-dwim)
           ("s-<mouse-1>" . mc/add-cursor-on-click)
           :map mc/keymap
           ("<return>" . nil)))
#+END_SRC

**** Phi-search
Incremental search thats multiple-cursors-friendly.

#+BEGIN_SRC emacs-lisp
  (use-package phi-search
    :after multiple-cursors
    :custom ((phi-search-case-sensitive 'guess)))

  (use-package phi-replace
    :straight nil
    :after phi-search
    :after multiple-cursors
    :bind (:map mc/keymap ([remap query-replace] . phi-replace-query)))
#+END_SRC

**** Symbol-overlay

#+BEGIN_SRC emacs-lisp
  (use-package symbol-overlay
    :after multiple-cursors
    :config
    (set-face-attribute 'symbol-overlay-default-face nil
                        :background (face-attribute 'default :background)
                        :foreground (face-attribute 'default :foreground)
                        :weight 'bold)

    (defun ar/mc-mark-all-symbol-overlays ()
      "Mark all symbol overlays using multiple cursors."
      (interactive)
      (mc/remove-fake-cursors)
      (if (or (region-active-p) (not (thing-at-point 'symbol t)))
          (mc/mark-all-dwim)

        (when-let* ((overlays (symbol-overlay-get-list 0))
                    (point (point))
                    (point-overlay (seq-find
                                    (lambda (overlay)
                                      (and (<= (overlay-start overlay) point)
                                           (<= point (overlay-end overlay))))
                                    overlays))
                    (offset (- point (overlay-start point-overlay))))
          (setq deactivate-mark t)
          (mapc (lambda (overlay)
                  (unless (eq overlay point-overlay)
                    (mc/save-excursion
                     (goto-char (+ (overlay-start overlay) offset))
                     (mc/create-fake-cursor-at-point))))
                overlays)
          (mc/maybe-multiple-cursors-mode))))

    :hook (prog-mode . symbol-overlay-mode)
    :bind (("s-D" . ar/mc-mark-all-symbol-overlays)
           ("M-n" . symbol-overlay-jump-next)
           ("M-p" . symbol-overlay-jump-prev)))
#+END_SRC

*** MWIM

#+begin_src emacs-lisp
  (use-package mwim
    :bind
    (("C-e" . mwim-end)
     ("C-a" . mwim-beginning)))
#+end_src

*** Comment line / region

#+BEGIN_SRC emacs-lisp
  (defun comment-line-or-region (beg end)
    "Comment a region or the current line."
    (interactive "*r")
    (save-excursion
      (if (region-active-p)
          (comment-or-uncomment-region beg end)
        (comment-line 1))))

  (global-set-key (kbd "C-\\") 'comment-line-or-region)
  (global-set-key (kbd "s-/") 'comment-line-or-region)
#+END_SRC

*** Select whole buffer

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "s-a") 'mark-whole-buffer)
#+END_SRC

*** Compilation mode tweaks

#+BEGIN_SRC emacs-lisp
  (use-package compile
    :straight nil
    :bind (("s-B" . compile) ("s-b" . recompile))
    :custom ((compilation-scroll-output t)))

  (use-package ansi-color
    :straight nil
    :config
    (defun colorize-compilation-buffer ()
      (read-only-mode)
      (ansi-color-apply-on-region compilation-filter-start (point))
      (read-only-mode))
    :hook ('compilation-filter . #'colorize-compilation-buffer))
#+END_SRC

*** Indent / Dedent
#+BEGIN_SRC emacs-lisp
  (defun dedent (start end)
    (interactive "*r")
    (indent-rigidly start end (- tab-width)))

  (defun indent (start end)
    (interactive "*r")
    (indent-rigidly start end tab-width))

  (global-set-key (kbd "s-[") 'dedent)
  (global-set-key (kbd "s-]") 'indent)
#+END_SRC

*** Guess indentation settings

#+BEGIN_SRC emacs-lisp
  (use-package dtrt-indent
    :config
    (dtrt-indent-mode 1))
#+END_SRC

*** Window navigation

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-j") (lambda () (interactive) (other-window -1)))
  (global-set-key (kbd "M-k") 'other-window)

  (use-package emacs
    :config
    (defun nuance/window-order (a b)
      (let ((a-left (window-pixel-left a))
            (b-left (window-pixel-left b))
            (a-top (window-pixel-top a))
            (b-top (window-pixel-top b)))
        (if (= a-top b-top) (< a-left b-left) (< a-top b-top))))

    (defun switch-to-nth-window (window-num)
      (select-window (elt (sort (window-list) #'nuance/window-order) window-num)))
    :bind (
           ("s-1" . (lambda () (interactive) (switch-to-nth-window 0)))
           ("s-2" . (lambda () (interactive) (switch-to-nth-window 1)))
           ("s-3" . (lambda () (interactive) (switch-to-nth-window 2)))
           ("s-4" . (lambda () (interactive) (switch-to-nth-window 3)))
           ("s-5" . (lambda () (interactive) (switch-to-nth-window 4)))
           ("s-6" . (lambda () (interactive) (switch-to-nth-window 5)))
           ("s-7" . (lambda () (interactive) (switch-to-nth-window 6)))
           ("s-8" . (lambda () (interactive) (switch-to-nth-window 7)))
           ("s-9" . (lambda () (interactive) (switch-to-nth-window 8)))))
#+END_SRC

*** Upcase / downcase

#+BEGIN_SRC emacs-lisp
  (put 'upcase-region 'disabled nil)
  (put 'downcase-region 'disabled nil)
#+END_SRC

*** Electric pair

#+BEGIN_SRC emacs-lisp
  (electric-pair-mode 1)
#+END_SRC

*** Auto revert

#+BEGIN_SRC emacs-lisp
  (customize-set-variable 'global-auto-revert-not-file-buffers t)
  (global-auto-revert-mode t)
#+END_SRC

*** window management

Mimic standard macos window / tab management commands

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "s-w") (lambda () (interactive) (kill-buffer nil)))
  (global-set-key (kbd "s-W") (lambda () (interactive) (kill-buffer nil) (delete-window)))
  (global-set-key (kbd "s-N") 'make-frame)
  (global-set-key (kbd "s-W") 'delete-frame)
  (global-set-key (kbd "s-s") 'save-buffer)
#+END_SRC

#+begin_src emacs-lisp
  (winner-mode t)
  (global-set-key (kbd "C-c 0") 'winner-undo)
#+end_src

*** scratch

#+begin_src emacs-lisp
  (use-package ielm
    :config
    (defun nuance/ielm-init-history ()
      (let ((path (expand-file-name "ielm/history" user-emacs-directory)))
        (make-directory (file-name-directory path) t)
        (setq-local comint-input-ring-file-name path))
      (setq-local comint-input-ring-size 10000)
      (setq-local comint-input-ignoredups t)
      (comint-read-input-ring))

    (defun nuance/ielm-write-history (&rest _args)
      (with-file-modes #o600
        (comint-write-input-ring)))

    (advice-add 'ielm-send-input :after 'nuance/ielm-write-history)

    :hook (ielm-mode . nuance/ielm-init-history)
    :bind (("s-n" . ielm)
           :map ielm-map
           ("C-l" . comint-clear-buffer)
           ("C-r" . consult-history)))
#+end_src

** vterm

#+BEGIN_SRC emacs-lisp
  (use-package vterm
    :demand t
    :hook (vterm-mode . goto-address-mode)
    :custom ((vterm-max-scrollback 0)
             (vterm-always-compile-module t))
    :config
    (add-to-list 'vterm-eval-cmds '("update-pwd" (lambda (path) (setq default-directory path))))

    (defun project-vterm ()
      (interactive)
      (let* ((default-directory (project-root (project-current t)))
             (vterm-buffer-name (project-prefixed-buffer-name "vterm"))
             (vterm-buffer (get-buffer vterm-buffer-name)))
        (if (and vterm-buffer (not current-prefix-arg))
            (pop-to-buffer vterm-buffer (bound-and-true-p display-comint-buffer-action))
          (vterm))))

    ;; unbind function keys
    (cl-loop for num from 1 to 12 do (unbind-key (kbd (format "<f%d>" num)) vterm-mode-map))
    :bind (("s-T" . project-vterm)
           :map vterm-mode-map
           ("<wheel-up>" . (lambda () (interactive) (vterm-send-key "<up>")))
           ("<wheel-down>" . (lambda () (interactive) (vterm-send-key "<down>")))))
#+END_SRC

** eshell

#+begin_src elisp
  (use-package eshell
    :ensure nil
    :hook ((eshell-mode . nuance/eshell-setup))
    :config
    (setq eshell-prompt-regexp "^[^#$\n]*[#$] "
          eshell-prompt-function
          (lambda nil
            (concat
             (if (string= (eshell/pwd) (getenv "HOME"))
                 "~" (eshell/basename (eshell/pwd)))
             (if (= (user-uid) 0) "#" "$")
             " ")))

    (defun nuance/eshell-setup ()
      (define-key eshell-hist-mode-map (kbd "C-r") 'consult-history)
      (define-key eshell-hist-mode-map (kbd "s-o") 'consult-outline)
      (setq-local outline-regexp eshell-prompt-regexp
                  completion-styles '(basic)
                  corfu-count 3
                  completion-at-point-functions '(pcomplete-completions-at-point cape-file cape-history)))

    (defun nuance/eshell-history-filter (input)
      "Do not save on the following:
           - empty lines
           - commands that start with a space, `cd`, `ls`/`l`"
      (and
       (eshell-input-filter-default input)
       (eshell-input-filter-initial-space input)
       (not (string-prefix-p "cd " input))
       (not (string-prefix-p "ls " input))))

    (defun eshell/cat-with-syntax-highlighting (filename)
      "Like cat(1) but with syntax highlighting.
  Stole from aweshell"
      (let ((existing-buffer (get-file-buffer filename))
            (buffer (find-file-noselect filename)))
        (eshell-print
         (with-current-buffer buffer
           (if (fboundp 'font-lock-ensure)
               (font-lock-ensure)
             (with-no-warnings
               (font-lock-fontify-buffer)))
           (let ((contents (buffer-string)))
             (remove-text-properties 0 (length contents) '(read-only nil) contents)
             contents)))
        (unless existing-buffer
          (kill-buffer buffer))
        nil))
    (advice-add 'eshell/cat :override #'eshell/cat-with-syntax-highlighting)

    :custom
    (eshell-scroll-to-bottom-on-input t)
    (eshell-highlight-prompt nil)
    (eshell-history-size 1024)
    (eshell-hist-ignoredups t)
    (eshell-input-filter 'nuance/eshell-history-filter)
    (eshell-cd-on-directory t)
    (eshell-list-files-after-cd nil)
    (eshell-pushd-dunique t)
    (eshell-last-dir-unique t)
    (eshell-last-dir-ring-size 32))

  (use-package eshell-syntax-highlighting
    :straight t
    :config (eshell-syntax-highlighting-global-mode t))
#+end_src

** Scroll through errors

This is really poorly structured, but flymake doesn't provide a
next-error-function implementation, so define a wrapper that navigates
between both flymake errors.

#+begin_src emacs-lisp
  (defun nuance/maybe-point (func)
    (let ((here (point)))
      (save-excursion (ignore-errors (call-interactively func)) (unless (eq (point) here) (point)))))

  (defun nuance/next-error ()
    (interactive)
    (let ((here (point))
          (points))
      (when (and (boundp 'flymake-mode) flymake-mode)
        (when-let ((p (nuance/maybe-point #'flymake-goto-next-error)))
          (push p points)))
      (when-let ((p (nuance/maybe-point #'next-error)))
        (push p points))
      (unless (null points) (goto-char (apply 'min points)))))

  (defun nuance/previous-error ()
    (interactive)
    (let ((here (point))
          (points))
      (when (and (boundp 'flymake-mode) flymake-mode)
        (when-let ((p (nuance/maybe-point #'flymake-goto-prev-error)))
          (push p points)))
      (when-let ((p (nuance/maybe-point #'previous-error)))
        (push p points))
      (unless (null points) (goto-char (apply 'max points)))))

  (bind-key (kbd "M-N") 'nuance/next-error)
  (bind-key (kbd "M-P") 'nuance/previous-error)
#+end_src

** Show flymake errors

#+begin_src elisp
  (use-package flymake-diagnostic-at-point
    :hook (flymake-mode . flymake-diagnostic-at-point-mode))
#+end_src

** Project Navigation

#+begin_src emacs-lisp
  (use-package memoize)

  (use-package project
    :straight t
    :config
    (defvar nuance/dotfiles-base-dir (expand-file-name "~/dotfiles"))
    (defvar nuance/dotfiles-dirs `(,nuance/dotfiles-base-dir ,(expand-file-name "~/.emacs.d") ,(expand-file-name "~/.config")))

    (defun project-find-dotfiles-dir (dir)
      (when (-any (lambda (p) (or (f-same? p dir) (f-ancestor-of? p dir))) nuance/dotfiles-dirs)
        (cons 'dotfiles-dir nuance/dotfiles-base-dir)))
    (memoize 'project-find-dotfiles-dir)

    (cl-defmethod project-root ((project (head dotfiles-dir)))
      (cdr project))

    (cl-defmethod project-files ((project (head dotfiles-dir)) &optional dirs)
      "Implementation of `project-files' for dotfiles projects."
      (cl-mapcan
       (lambda (dir) (cl-call-next-method))
       (or dirs (project-roots project))))

    (add-hook 'project-find-functions #'project-find-dotfiles-dir)
    :bind (("s-," . (lambda () (interactive) (find-file (concat user-emacs-directory "init.org"))))
           ("s-<" . (lambda () (interactive) (find-file (concat user-emacs-directory "private.org"))))))
#+end_src

*** Find by name

#+begin_src emacs-lisp
  (use-package project
    :straight t
    :after (consult)

    :init
    (cl-defgeneric nuance/project-find-by-name-cmd (project q)
      (let* ((split (split-string q " " t))
             (pattern (format "(%s){%d}+" (s-join "|" (mapcar (lambda (s) (format "%s.*" s)) split)) (length split))))
        (format "fd --hidden --no-ignore --color=never --max-results=%d \"%s\" %s" (* 5 nuance/completion-candidates) pattern (project-root project))))

    (cl-defgeneric nuance/project-find-by-name-initial (project) "" nil "")
    (cl-defgeneric nuance/project-find-by-name-path (project result)
      (f-relative (concat (file-remote-p default-directory) (string-remove-prefix "./" x)) default-directory))

    (defvar nuance/find-by-name-history nil)
    (add-to-list 'savehist-additional-variables 'nuance/find-by-name-history)

    :config
    (defun nuance/find-by-name (project prompt builder initial)
      (consult--read
       (consult--async-command builder
         (consult--async-map (lambda (x) (nuance/project-find-by-name-path project x)))
         (consult--async-highlight builder)
         :file-handler t) ;; allow tramp
       :prompt prompt
       :sort nil
       :require-match t
       :initial (consult--async-split-initial initial)
       :add-history (consult--async-split-thingatpt 'filename)
       :category 'file
       :history '(:input nuance/find-by-name-history)))

    (defun nuance/find-by-name-builder (project input)
      "Build command line given INPUT."
      (pcase-let* ((cmd (nuance/project-find-by-name-cmd project input))
                   (`(,arg . ,opts) (consult--command-split input))
                   (`(,re . ,hl) (funcall consult--regexp-compiler arg 'basic t)))
        (when re
          (cons (split-string-and-unquote cmd) hl))))

    (defun project-find-file-in (filename dirs project &optional include-all)
      "Search for regexp with find in DIR with INITIAL input.
    The find process is started asynchronously, similar to `consult-grep'.
    See `consult-grep' for more details regarding the asynchronous search."
      (interactive "P")
      (let* ((default-directory (project-root project))
             (prompt (format "%s: " (project-name project)))
             (builder (lambda (input) (nuance/find-by-name-builder project input)))
             (initial (concat (nuance/project-find-by-name-initial project) (thing-at-point 'filename)))
             (path (nuance/find-by-name project prompt builder initial)))
        (xref-push-marker-stack)
        (find-file path)))

    (defun nuance/find-in-dotfiles ()
      (interactive)
      (let ((default-directory "~/dotfiles")) (project-find-file)))

    :bind (("s-p" . project-find-file)))
#+end_src

*** Find by content

#+begin_src emacs-lisp
  (use-package project
    :straight t
    :after (consult)
    :init
    (cl-defgeneric nuance/find-by-content-dispatch (project) "" nil
                   (consult-git-grep))

    :config
    (defun nuance/find-by-content ()
      "Search for regexp with find in DIR with INITIAL input.
      The find process is started asynchronously, similar to `consult-grep'.
      See `consult-grep' for more details regarding the asynchronous search."
      (interactive)
      (nuance/find-by-content-dispatch (project-current)))

    :bind (("s-f" . nuance/find-by-content)))
#+end_src

*** Find changed

#+begin_src emacs-lisp
  (use-package project
    :straight t
    :config
    (cl-defgeneric nuance/project-list-changed (project)
      "Default find-changed implementation for projects using magit."
      (unless (magit-inside-worktree-p) (user-error "Non git-managed projects unsupported."))

      (let ((status (magit-git-lines "status" "--porcelain"))
            (latest-commit-files )
            (result '()))
        (if status
            (mapcar (lambda (file) (substring file 3)) status)
          (magit-git-lines "diff-tree" "--no-commit-id" "--name-only" "-r" "HEAD"))))

    (defun nuance/project-find-changed ()
      "Find modified files."
      (interactive)
      (if-let ((default-directory (project-root (project-current)))
               (paths (nuance/project-list-changed (project-current)))
               (selection (consult--read paths :prompt "Changed: " :sort nil :require-match t :category 'file)))
          (find-file (f-join (project-root (project-current)) selection))))

    :bind (("s-g" . nuance/project-find-changed)))
#+end_src

*** Find changed by content

#+begin_src emacs-lisp
  (use-package project
    :straight t
    :config
    (cl-defgeneric nuance/project-list-changed-content (project)
      "Default find-changed-content implementation for projects using magit."
      (unless (magit-inside-worktree-p) (user-error "Non git-managed projects unsupported."))

      (let* ((diff-output (magit-git-lines "diff" "-U0" "--no-color"))
             (result '())
             current-file
             current-line)
        (dolist (line diff-output (nreverse result))
          (cond
           ;; New file
           ((string-prefix-p "+++ b/" line)
            (setq current-file (substring line 6)))
           ;; Hunk header
           ((string-match (rx line-start "@@ -" (group-n 1 (one-or-more digit)) (optional "," (one-or-more digit))  " +" (group-n 2 (one-or-more digit)) (optional "," (one-or-more digit)) " @@") line)
            (setq current-line (string-to-number (match-string 2 line))))
           ;; Added line
           ((string-prefix-p "+ " line)
            (when (and current-file current-line)
              (push (format "%s:%d:%s" current-file current-line line) result))
            (setq current-line (1+ current-line)))
           ;; Removed line
           ((string-prefix-p "- " line)
            (when (and current-file current-line)
              (push (format "%s:%d:%s" current-file current-line line) result)))))))

    (defun nuance/project-find-changed-content ()
      "Find modified files by filtering diff output."
      (interactive)
      (if-let ((default-directory (project-root (project-current)))
               (paths (nuance/project-list-changed-content (project-current)))
               (selection (consult--read paths :prompt "Changed: " :sort nil :require-match t :category 'file))
               (path (nth 0 (split-string selection ":")))
               (line (string-to-number (nth 1 (split-string selection ":")))))
          (progn
            (find-file path)
            (goto-char (point-min))
            (forward-line (1- line)))))

    :bind (("s-G" . nuance/project-find-changed-content)))
#+end_src

*** Code URL

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :config (cl-defgeneric nuance/buffer-url (project) (interactive) (error "nuance/buffer-url unimplemented"))
    :bind ("s-u" . (lambda () (interactive) (nuance/buffer-url (project-current)))))
#+END_SRC

** Find alternatives

#+begin_src emacs-lisp
  (use-package emacs
    :custom (find-sibling-rules
             `(
               ;; Source -> source
               (,(rx (group (+ (not "/")))
                     "." (or "c" "cc" "h" "py" "go" "org" "el")
                     string-end)
                ,(rx (regex "\\1")
                     "."  (or "c" "cc" "h" "py" "go" "org" "el")
                     string-end))
               ;; Source -> test
               (,(rx (group (+? (not "/"))) (? "_test")
                     "." (group (or "c" "cc" "h" "py" "go"))
                     string-end)
                ,(rx (regex "\\1") (? "_test")
                     "." (regex "\\2")
                     string-end))))
    :bind ("s-y" . find-sibling-file))
#+end_src

** Open links

#+begin_src emacs-lisp
  (use-package goto-addr
    :straight nil
    :bind ("C-c C-o" . goto-address-at-point))
#+end_src

** Operate on lines if no region set

#+begin_src emacs-lisp
  (use-package whole-line-or-region
    :config (whole-line-or-region-global-mode))
#+end_src

** Reload files

#+begin_src emacs-lisp
  (global-set-key (kbd "s-r") 'revert-buffer)
#+end_src

** Terminal Mouse

#+begin_src emacs-lisp
  (when (not (window-system)) (xterm-mouse-mode))
#+end_src

** Tabs

#+begin_src emacs-lisp
  (global-set-key (kbd "s-}") 'tab-next)
  (global-set-key (kbd "s-{") 'tab-previous)
  (global-set-key (kbd "C-x T") 'tab-switch)
#+end_src

** Global Mark Ring

#+begin_src emacs-lisp
  (setq global-mark-ring-max 1024)
  (global-set-key (kbd "s-.") #'consult-global-mark)
#+end_src

* Packages

** Magit

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :commands magit-status magit-blame-addition
    :custom ((magit-branch-arguments nil)
             ;; don't put "origin-" in front of new branch names by default
             (magit-default-tracking-name-function 'magit-default-tracking-name-branch-only)
             (magit-push-always-verify nil)
             ;; Get rid of the previous advice to go into fullscreen
             (magit-restore-window-configuration t)
             (git-commit-fill-column 120))
    :init
    (cl-defgeneric nuance/status (project)
      (magit-status (project-root project)))
    :bind ("C-x g" . (lambda () (interactive) (nuance/status (project-current)))))
#+end_src

** Diff Highlight

#+BEGIN_SRC emacs-lisp
  (use-package diff-hl
    :config
    (global-diff-hl-mode)
    (diff-hl-margin-mode)
    (global-diff-hl-amend-mode)
    (global-diff-hl-show-hunk-mouse-mode)
    (diff-hl-flydiff-mode))
#+END_SRC

** Ediff

#+begin_src emacs-lisp
  (use-package ediff
    :custom ((ediff-window-setup-function 'ediff-setup-windows-plain)))
#+end_src

*** yasnippet

Include yasnippet for eglot usage.

#+begin_src emacs-lisp
  (use-package yasnippet
    :hook (prog-mode . yas-minor-mode))
#+end_src

** LSP
#+BEGIN_SRC emacs-lisp
  (use-package eglot
    :demand t
    :config
    (setq-default
     eglot-workspace-configuration '((:gopls . ((usePlaceholders . t)
                                                (allExperiments . t)
                                                (staticcheck . t)
                                                (analyses . (
                                                             (nilness . t)
                                                             (fieldalignment . t)
                                                             (shadow . t)
                                                             (unusedparams . t)
                                                             (unusedwrite . t)))
                                                (matcher . "Fuzzy"))))
     eglot-events-buffer-size 10000
     eglot-sync-connect 0)

    (defun nuance/eglot-organize-imports ()
      (ignore-errors (eglot-code-action-organize-imports (point-min))))

    ;; Optional: install eglot-format-buffer as a save hook.
    ;; The depth of -10 places this before eglot's willSave notification,
    ;; so that that notification reports the actual contents that will be saved.
    (defun nuance/eglot-format-buffer-on-save ()
      (add-hook 'before-save-hook (lambda () (unless nuance/skip-format-on-save (nuance/eglot-organize-imports))) -11 t)
      (add-hook 'before-save-hook (lambda () (unless nuance/skip-format-on-save (eglot-format-buffer))) -10 t))

    (define-minor-mode nuance/skip-format-on-save
      "Don't call eglot format / organize imports when enabled")
    (defun eglot-rename
        (newname)
      "Rename the current symbol to NEWNAME."
      (interactive
       (list
        (read-from-minibuffer
         (format "Rename `%s' to: "
                 (or
                  (thing-at-point 'symbol t)
                  "unknown symbol"))
         (thing-at-point 'symbol t) nil nil nil
         (symbol-name
          (symbol-at-point)))))
      (eglot-server-capable-or-lose :renameProvider)
      (eglot--apply-workspace-edit
       (eglot--request (eglot--current-server-or-lose)
                       :textDocument/rename `(,@(eglot--TextDocumentPositionParams)
                                              :newName ,newname))
       this-command))

    :hook
    (((python-mode c++-mode c-mode go-mode rust-mode) . eglot-ensure)
     (eglot-managed-mode . nuance/eglot-format-buffer-on-save))
    :bind (:map eglot-mode-map
                ("C-c r" . eglot-rename)
                ("C-c f" . eglot-format)
                ("C-c a" . eglot-code-actions)))
#+END_SRC

** Org
*** Installation

#+begin_src emacs-lisp
  (use-package org
    :demand t
    :custom ((org-special-ctrl-a/e t)
             (org-startup-folded t)
             (org-pretty-entities t)
             (org-src-tab-acts-natively t)
             (org-src-window-setup 'plain)
             (org-element-use-cache nil)
             (org-element-cache-persistent nil))
    :config (setq org-capture-templates '())

    (setq org-refile-targets
          `((nil :maxlevel . 9)
            (,(directory-files-recursively "~/org" "^[^.].*[.]org$") :maxlevel . 3)
            (org-agenda-files :maxlevel . 3)))
    (setq org-outline-path-complete-in-steps nil)
    (setq org-refile-use-outline-path 'file)
    :hook
    ((org-mode . visual-line-mode)
     (org-mode . (lambda ()
                   (org-content 2)))
     (before-save . (lambda () (when (eq major-mode 'org-mode) (indent-region (buffer-end -1) (buffer-end 1))))))
    :bind
    (("C-c c" . org-capture)
     ("C-c l" . org-store-link)))
#+end_src
*** Poly-org

For better inline code editing.

#+BEGIN_SRC emacs-lisp
  (use-package poly-org)
#+END_SRC

*** org-nv2

My personal note taking app, now with some basic llm powers.

#+begin_src elisp
  (setq nuance/nv2-path (expand-file-name "~/org/nv"))

  (defun nuance/nv2--create-note (name)
    "Create a new note, returning the resulting path."
    (let ((path (f-join nuance/nv2-path
                        (concat
                         (replace-regexp-in-string " +" "_" (downcase name))
                         ".org"))))
      (find-file path)
      (insert (format "#+TITLE: %s\n" (capitalize name)))
      (org-time-stamp '(16))
      (insert "\n\n")
      (org-mode)
      (save-buffer)
      path))

  (cl-defstruct nuance/nv2-result path title)

  (defun nuance/nv2-result-body (note)
    (f-read-text (nuance/nv2-result-path note)))

  (defun nuance/nv2-result-from-path (path)
    (make-nuance/nv2-result :path path :title (nuance/nv2--get-org-title-from-file path)))

  (defun nuance/nv2-result-to-string (note)
    (format "(make-nuance/nv2-result-from-path %S)" (nuance/nv2-result-path note)))

  (defun nuance/nv2--get-org-title-from-file (path)
    "Return the title of the Org-mode document specified by PATH."
    (with-temp-buffer
      (insert-file-contents path)
      (let* ((data (org-element-parse-buffer 'element))
             (title (org-element-map data 'keyword
                      (lambda (el)
                        (when (string= (org-element-property :key el) "TITLE")
                          (org-element-property :value el)))
                      nil t)))
        (or title path))))

  (defun nuance/nv2--dates-in-file (path)
    "List all dates in the Org file specified by PATH."
    (with-temp-buffer
      (insert-file-contents path)
      (let* ((parsed-data (org-element-parse-buffer))
             (timestamps (org-element-map parsed-data 'timestamp
                           (lambda (timestamp)
                             (org-element-property :raw-value timestamp)))))
        timestamps)))

  (defun nuance/nv2--search-matcher (query)
    "Construct a callable matcher that takes a file path and returns a nuance/nv2-result or nil."
    (cond ((length= query 0) (lambda (path) nil))
          ((s-prefix? "<" query)
           (lambda (path)
             (if-let* ((timestamps (nuance/nv2--dates-in-file path))
                       (query-date (substring query 1))
                       (matches (seq-filter (lambda (dt) (s-contains-p query-date dt)) timestamps)))
                 (nuance/nv2-result-from-path path))))
          ((s-prefix? ":" query) (lambda (path) (nuance/nv2-result-from-path path)))
          (t (lambda (path) (if (s-contains? query path) (nuance/nv2-result-from-path path) (let ((body (f-read-text path))) (when (s-contains? query body) (nuance/nv2-result-from-path path))))))))

  (defun nuance/nv2--execute-search (text)
    "Return a list of nuance/nv2-result.
                  Query syntax:
                   'text' - match text
                   ':text' - match embedding
                   '<date>' - match dates
                "
    (file-cache-add-directory-recursively nuance/nv2-path (rx (one-or-more anychar) ".org"))
    (let* ((query (nuance/nv2--search-matcher text))
           (all-notes (find-lisp-find-files nuance/nv2-path (rx (one-or-more anychar) ".org")))
           (matches (remove nil (mapcar query all-notes))))
      (mapcar #'nuance/nv2-result-path matches)))

  (defun nuance/nv2--query ()
    "Run a query session, returning zero or one result."
    (if-let ((path (completing-read
                    ": "
                    (nuance/complete-dynamic #'nuance/nv2--execute-search)
                    nil
                    nil
                    (dwim-default-text))))
        (if (f-exists? path)
            (nuance/nv2-result-from-path path)
          (nuance/nv2-result-from-path (nuance/nv2--create-note path)))))

  (defun nuance/nv2--query-many ()
    "Run a query session, returning zero or more results."
    (if-let ((result (nuance/nv2--query)))
        (list result)))

  (defun nuance/nv2-navigate ()
    "Display a filterable list of notes."
    (interactive)
    (let ((selection (nuance/nv2--query)))
      (find-file (nuance/nv2-result-path selection))))

  (defun nuance/nv2-refer ()
    "Insert a reference to the result of a search."
    (interactive)
    (if-let ((note (nuance/nv2--query)))
        (insert "[[" (nuance/nv2-result-path note) "][" (nuance/nv2-result-title note) "]]")))

  (defun nuance/nv2-discuss ()
    "Insert a chat block in an existing note."
    (interactive)
    (let* ((notes-source (if (region-active-p)
                             `(region . (,(region-beginning) ,(region-end)))
                           `(notes . ,(nuance/nv2--query-many))))
           (source (car notes-source))
           (data (cdr notes-source))
           (prompt (read-string "> ")))

      (insert "#+begin_src emacs-lisp\n")
      (cond
       ((equal source 'region) (insert (format "(nuance/nv2--chat-region %S %S %S)\n" prompt (car data) (cadr data))))
       ((equal source 'notes) (insert (format "(nuance/nv2--chat-notes %S (list %s))\n" prompt (mapconcat (lambda (note) (nuance/nv2-result-to-string note)) data)))))
      (insert "#+end_src\n")))

  (defun nuance/nv2--chat-region (prompt start end)
    (let ((prompt-context (format "Given selected text: ```%s\n%s```" major-mode (buffer-substring-no-properties start end))))
      (llm-chat nuance/llm-provider (llm-make-simple-chat-prompt (concat prompt prompt-context)))))

  (defun nuance/nv2--chat-notes (prompt notes)
    (let* ((prompt-context (if notes (concat "Given selected sources:\n" (mapconcat (lambda (note) (format "```%s\n%s\n```\n" (nuance/nv2-result-path note) (nuance/nv2-result-body note))) notes)))))
      (llm-chat nuance/llm-provider (llm-make-simple-chat-prompt (concat prompt prompt-context)))))

  (global-set-key (kbd "C-c k") #'nuance/nv2-navigate)
  (global-set-key (kbd "C-c l") #'nuance/nv2-refer)
  (global-set-key (kbd "C-c e") #'nuance/nv2-discuss)
#+end_src

** LLM

*** ollama

#+begin_src emacs-lisp
  (use-package llm
    :config
    (require 'llm-ollama)
    (setq nuance/llm-provider (make-llm-ollama :chat-model "gemma:instruct" :embedding-model "gemma:instruct"))

    (defun nuance/llm-chat-buffer ()
      (interactive)
      (let ((scope (if (region-active-p) "region" "buffer"))
            (contents (if (region-active-p) (buffer-substring-no-properties (region-beginning) (region-end))
                        (buffer-substring-no-properties (point-min) (point-max)))))
        (message "%s" (llm-chat nuance/llm-provider
                                (llm-make-simple-chat-prompt
                                 (format "%s\nGiven the following emacs %s with major mode `%s` contents:\n\n```%s```" (read-string "> ") scope major-mode contents)))))))
#+end_src

*** shell-maker

#+BEGIN_SRC emacs-lisp
  (use-package shell-maker
    :straight (:host github :repo "xenodium/chatgpt-shell" :files ("shell-maker.el")))
#+END_SRC

** Tramp

#+BEGIN_SRC emacs-lisp
  (use-package tramp
    :straight nil
    :custom
    ((tramp-inline-compress-start-size (* 64 1024))
     (tramp-default-method "ssh")
     (tramp-terminal-type "tramp")
     (remote-file-name-inhibit-locks t)
     (tramp-use-ssh-controlmaster-options nil)
     (tramp-verbose 0))
    :config
    (add-to-list 'tramp-remote-path 'tramp-own-remote-path)
    (add-to-list 'tramp-sh-file-name-handler-alist `(file-truename . ,#'identity))
    :hook (compilation-mode . (lambda () (add-to-list 'tramp-sh-file-name-handler-alist `(file-truename . ,#'identity)))))
#+END_SRC

** ElDoc

#+BEGIN_SRC emacs-lisp
  (use-package eldoc :hook ((prog-mode org-mode) . eldoc-mode))
  (use-package eldoc-box :hook ((prog-mode org-mode) . eldoc-box-hover-at-point-mode))
#+END_SRC

** which-key

#+begin_src emacs-lisp
  (use-package which-key
    :config (which-key-mode))
#+end_src

** Helpful

#+begin_src emacs-lisp
  (use-package helpful

    :bind (
           ([remap describe-function] . 'helpful-callable)
           ([remap describe-variable] . 'helpful-variable)
           ([remap describe-key] . 'helpful-key)
           ([remap describe-command] . 'helpful-command)
           ([remap describe-symbol] . 'helpful-symbol)
           ("C-h F" . 'helpful-function)
           ("C-c C-d" . 'helpful-at-point)
           ("C-h C" . 'helpful-command)
           :map helpful-mode-map ([remap revert-buffer] . 'helpful-update)))
#+end_src

*** elisp-demos

#+begin_src emacs-lisp
  (use-package elisp-demos
    :after helpful
    :config
    (advice-add 'helpful-update :after #'elisp-demos-advice-helpful-update))
#+end_src

* File-type support

** Toggleable function narrowing

#+BEGIN_SRC emacs-lisp
  (put 'narrow-to-region 'disabled nil)
#+END_SRC

** JSON

#+BEGIN_SRC emacs-lisp
  (use-package json-mode
    :mode "\\.json\\'")
#+END_SRC

** YAML
#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :mode "\\.yml\\'")
#+END_SRC

** Protobuf

#+BEGIN_SRC emacs-lisp
  (use-package protobuf-mode)
#+END_SRC

** C++

#+BEGIN_SRC emacs-lisp
  (use-package cc-mode
    :straight nil
    :config
    (defun my/c-indent-complete ()
      (interactive)
      (let ((p (point)))
        (c-indent-line-or-region)
        (when (= p (point))
          (call-interactively 'complete-symbol))))
    :mode ("\\.h|\\.cpp" . c++-mode)
    :bind (:map c-mode-base-map ("TAB" .  my/c-indent-complete)))
#+END_SRC

** Python

#+BEGIN_SRC emacs-lisp
  (use-package python)
#+END_SRC

** Rust

#+BEGIN_SRC emacs-lisp
  (use-package rust-mode)
#+END_SRC

** Go

#+BEGIN_SRC emacs-lisp
  (use-package go-mode)
#+END_SRC

** Bazel

#+BEGIN_SRC emacs-lisp
  (use-package bazel
    :mode ("'BUILD'" "'WORKSPACE'" "\\.bzl\\'" "'TARGETS'")
    :custom
    ((bazel-mode-buildifier-before-save t)
     (bazel-mode-buildifier-command "~/go/bin/buildifier"))
    :config
    (remove-hook 'project-find-functions #'bazel-find-project))
#+END_SRC

** Markdown

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :commands (markdown-mode gfm-mode)
    :mode (("README\\.md\\'" . gfm-mode)
           ("\\.md\\'" . markdown-mode)
           ("\\.markdown\\'" . markdown-mode))
    :init (setq markdown-command "multimarkdown"
                markdown-header-scaling t
                markdown-hide-urls t
                markdown-marginalize-headers nil
                markdown-marginalize-headers-margin-width 4
                markdown-fontify-code-blocks-natively t)
    :hook
    (('markdown-mode .'variable-pitch-mode)
     ('markdown-mode . 'visual-line-mode)))

  (use-package edit-indirect)
#+END_SRC

* Private.el
I'd like to keep a few settings private, so we load a =private.el= if it exists after the init-file has loaded.

#+BEGIN_SRC emacs-lisp
  (let ((private-file (concat user-emacs-directory "private.el"))
        (straight-current-profile 'private))
    (when (file-exists-p private-file)
      (load-file private-file)))
#+END_SRC

* Startup
Launch a server if not currently running.

#+BEGIN_SRC emacs-lisp
  (setq server-use-tcp t)
  (setq server-port 42069)
  (setq server-auth-key "emacskeyemacskeyemacskeyemacskeyemacskeyemacskeyemacskeyemacskey")

  (when (not noninteractive) (server-start))
#+END_SRC
