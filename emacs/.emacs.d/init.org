#+TITLE: Emacs configuration file
#+AUTHOR: Matthew Jones
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle yes
#+PROPERTY: header-args:elisp :lexical t

* Configurations
** Lexical binding

I want lexical scoping for the init-file, which can be specified in the
header. The first line of the configuration is as follows:

#+BEGIN_SRC emacs-lisp
  ;;; -*- lexical-binding: t -*-
#+END_SRC

#+begin_src emacs-lisp :tangle "early-init.el"
  ;;; -*- lexical-binding: t -*-
#+end_src

** Auto-tangling

The =init.el= should (after the first run) mirror the source blocks in
the =init.org=. We can use =C-c C-v t= to run =org-babel-tangle=, which
extracts the code blocks from the current file into a source-specific
file (in this case a =.el=-file).

To avoid doing this each time a change is made we can add a function to
the =after-save-hook= ensuring to always tangle and byte-compile the
=org=-document after changes.

#+BEGIN_SRC emacs-lisp
  (defun tangle-init ()
    "If the current buffer is 'init.org' the code-blocks are
  tangled, and the tangled file is compiled."
    (when (or (equal (buffer-file-name)
                     (expand-file-name (concat user-emacs-directory "init.org")))
              (equal (buffer-file-name)
                     (expand-file-name (concat user-emacs-directory "private.org"))))
      ;; Avoid running hooks when tangling.
      (let ((prog-mode-hook nil))
        (org-babel-tangle))))

  (add-hook 'after-save-hook 'tangle-init)
#+END_SRC

* early-init

#+begin_src emacs-lisp :tangle "early-init.el"
  ;; Defer garbage collection further back in the startup process
  (setq gc-cons-threshold most-positive-fixnum)

  (setq ns-use-thin-smoothing t
        ns-use-proxy-icon nil

        tab-bar-show nil
        frame-title-format "%b - emacs"
        frame-resize-pixelwise t
        window-resize-pixelwise t
        default-frame-alist `((ns-transparent-titlebar . t)
                              (width . 170)
                              (height . 50)))

  ;; Prevent the glimpse of un-styled Emacs by disabling these UI elements early.
  (push '(menu-bar-lines . 0) default-frame-alist)
  (push '(tool-bar-lines . 0) default-frame-alist)
  (push '(vertical-scroll-bars) default-frame-alist)

  ;; Resizing the Emacs frame can be a terribly expensive part of changing the
  ;; font. By inhibiting this, we easily halve startup times with fonts that are
  ;; larger than the system default.
  (setq frame-inhibit-implied-resize t)

  ;; Ignore X resources; its settings would be redundant with the other settings
  ;; in this file and can conflict with later config (particularly where the
  ;; cursor color is concerned).
  (advice-add #'x-apply-session-resources :override #'ignore)

  (setq comp-deferred-compilation-deny-list ".*")
  (setq native-comp-deferred-compilation nil
        native-comp-async-report-warnings-errors nil)
  (setq package-enable-at-startup t)
#+end_src

* Straight.el

** bootstrap

#+BEGIN_SRC emacs-lisp
  (setq straight-repository-branch "develop")
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 6))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
#+END_SRC

** startup

#+begin_src emacs-lisp :tangle "early-init.el"
  (setq straight-check-for-modifications '(find-when-checking check-on-save))
#+end_src

** use-package

#+BEGIN_SRC emacs-lisp
  (straight-use-package 'use-package)
  (setq straight-use-package-by-default t)
  (setq use-package-verbose t)
#+END_SRC

** Package management

#+begin_src emacs-lisp
  (defun nuance/update-versions ()
    (interactive)
    (straight-pull-all))

  (defun nuance/native-compile ()
    (interactive)
    (when (featurep 'native-compile)
      (let
          ((native-comp-deferred-compilation t)
           (native-comp-async-jobs-number (cl-parse-integer (s-trim (shell-command-to-string "getconf _NPROCESSORS_ONLN")))))
        (native-compile-async "~/.emacs.d/straight/build" 'recursively)
        (while
            (and comp-files-queue (> (comp-async-runnings) 0))
          (progn (message "comp-files-queue: %s | comp-async-runnings: %d" (and comp-files-queue (length comp-files-queue)) (comp-async-runnings))
                 (sleep-for 1))))))
#+end_src

* Performance optimizations

Mostly adapted from [[https://github.com/zzamboni/dot-emacs/blob/master/init.org#performance-optimization][dot-emacs/init.org at master Â· zzamboni/dot-emacs]]

** Disable file handlers

#+BEGIN_SRC emacs-lisp
  (setq
   nuance/file-name-handler-alist file-name-handler-alist
   file-name-handler-alist nil)
  (add-hook 'after-init-hook (lambda () (setq file-name-handler-alist nuance/file-name-handler-alist)))
#+END_SRC

** Report startup performance

#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-startup-hook
            (lambda ()
              (message "Emacs ready in %s with %d garbage collections."
                       (emacs-init-time "%.2f seconds")
                       gcs-done)))
#+END_SRC

** Increase read process output buffer size

#+begin_src emacs-lisp
  (setq read-process-output-max (* 1024 1024)) ;; 1mb
#+end_src

** Cache SSL lookups

#+BEGIN_SRC emacs-lisp
  (customize-set-variable 'nsm-settings-file (concat user-emacs-directory "network-security.data"))
#+END_SRC

** Clean up old buffers

#+begin_src emacs-lisp
  (midnight-mode t)
#+end_src

* Disable nswin keybindings
I don't really want all the default super bindings (I'd prefer a simpler emacs experience).

#+BEGIN_SRC emacs-lisp
  (custom-set-variables
   '(mac-command-modifier (quote super))
   '(mac-option-modifier (quote meta))
   '(mac-pass-command-to-system nil)
   '(mac-pass-control-to-system nil))

  (let
      ((unbind-keys
        '(
          [?\s-,]
          [?\s-']
          [?\s-`]
          [?\s-~]
          ;; [?\s--]
          [?\s-:]
          [?\s-?]
          [?\s-^]
          [?\s-&]
          [?\s-C]
          [?\s-D]
          [?\s-E]
          [?\s-L]
          [?\s-M]
          [?\s-S]
          [?\s-a]
          ;; [?\s-c]
          [?\s-d]
          [?\s-e]
          [?\s-f]
          [?\s-g]
          [?\s-h]
          [?\s-H]
          [?\M-\s-h]
          [?\s-j]
          [?\s-k]
          [?\s-l]
          [?\s-m]
          [?\s-n]
          [?\s-o]
          [?\s-p]
          [?\s-q]
          [?\s-s]
          [?\s-t]
          [?\s-u]
          ;; [?\s-v]
          [?\s-w]
          [?\s-x]
          [?\s-y]
          [?\s-z]
          [?\s-|]
          [s-kp-bar]
          [s-right]
          [s-left]
          [home]
          [end]
          [kp-home]
          [kp-end]
          [kp-prior]
          [kp-next]
          [S-mouse-1]
          [swipe-left]
          [swipe-right]
          [magnify-up]
          [magnify-down]
          [S-magnify-up]
          [S-magnify-down]
          )))
    (seq-map (lambda (key) (global-unset-key key)) unbind-keys))

#+END_SRC

* Niceities
** File I/O

#+BEGIN_SRC emacs-lisp
  (set-language-environment "UTF-8")
  (set-default-coding-systems 'utf-8)

  (setq load-prefer-newer t
        save-place-file (concat user-emacs-directory "places")
        backup-directory-alist `(("." . ,(concat user-emacs-directory "backups")))
        backup-inhibited t
        sentence-end-double-space nil       ; No double space
        vc-follow-symlinks nil)
#+END_SRC

** Disable custom

#+BEGIN_SRC emacs-lisp
  (setq custom-file (make-temp-file ""))   ; Discard customization's
#+END_SRC

** Load environment variables

#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :custom ((exec-path-from-shell-variables '("PATH" "MANPATH" "SSH_AUTH_SOCK")))
    :config (exec-path-from-shell-initialize))
#+END_SRC

** Elisp helpers

#+BEGIN_SRC emacs-lisp
  ;; functional helpers
  (use-package dash)

  ;; string manipulation
  (use-package s)

  ;; filepath manipulation
  (use-package f)

  (use-package compat)
#+END_SRC

** Encrypted authinfo

#+begin_src emacs-lisp
  (setq auth-sources '((:source "~/.authinfo.gpg")))
#+end_src

** so-long

#+begin_src emacs-lisp
  (use-package so-long
    :config (global-so-long-mode 1)
    ;; Force so-long to be on in compilation buffers
    :hook (compilation-mode . so-long-minor-mode))
#+end_src

** Confirm exit

#+begin_src emacs-lisp
  (setq confirm-kill-emacs 'yes-or-no-p)
#+end_src

** FFAP

#+begin_src emacs-lisp
  (ffap-bindings)
#+end_src

** URL Handler

Handle emacs:// urls, forwarded by a script application:

#+begin_src applescript :tangle no
on open location URL
	do shell script "/Users/matt/.nix-profile/bin/emacsclient --eval '(nuance/handle-url \"" & URL & "\")"
end open location
#+end_src

With the following added to the Info.plist:

#+begin_src xml :tangle no
  <key>CFBundleURLTypes</key>
  <array>
    <dict>
      <key>CFBundleURLName</key>
      <string>EmacsClientCapture</string>
      <key>CFBundleURLSchemes</key>
      <array>
        <string>org-protocol</string>
      </array>
    </dict>
  </array>
#+end_src

#+begin_src emacs-lisp
  (setq nuance/url-handlers nil)
  (defun nuance/handle-url (url)
    (let* ((parsed (url-generic-parse-url url))
           (method (url-host parsed))
           (args (url-parse-query-string (cdr (url-path-and-query parsed))))
           (handler (alist-get method nuance/url-handlers nil nil 'equal)))
      (if handler
          (funcall handler args)
        (warn "unknown url handler: %s" method))))
#+end_src

Add a handler like:

#+begin_src emacs-lisp
  (add-to-list
   'nuance/url-handlers
   (cons "find-file"
         (lambda (parts)
           (find-file (car (alist-get "path" parts nil nil 'equal))))))
#+end_src

And test it like:

#+begin_src bash :tangle no
  open "emacs://find-file?path=/tmp/foobar"
#+end_src

** Restore state between relaunches

#+begin_src emacs-lisp
  (setq savehist-save-minibuffer-history nil)
  (savehist-mode 1)
  (add-to-list 'savehist-additional-variables 'compile-command)
  (add-to-list 'savehist-additional-variables 'xref--history)

  (recentf-mode 1)
  (save-place-mode 1)
#+end_src

** Kill / yank

#+begin_src emacs-lisp
  (customize-set-variable 'kill-do-not-save-duplicates t)
  ;; raycast will send s-v to trigger a paste
  (global-set-key (kbd "s-v") 'yank)
#+end_src

** Executable bit

#+begin_src emacs-lisp
  (add-hook 'after-save-hook #'executable-make-buffer-file-executable-if-script-p)
#+end_src

** Buffer Rules

Largely based on [[https://www.masteringemacs.org/article/demystifying-emacs-window-manager][Mastering Emacs - Demystifying Emacs's Window Manager]]

#+begin_src emacs-lisp
  (setq switch-to-buffer-obey-display-actions nil)
  (setq switch-to-buffer-in-dedicated-window 'pop)
  (setq window-sides-slots '(1 1 1 1))
  (global-set-key (kbd "C-x !") 'window-toggle-side-windows)
  (global-set-key (kbd "<f1>") 'window-toggle-side-windows)
  (global-set-key (kbd "<f2>") 'balance-windows)

  (defun nuance/display-buffer-in-bottom-drawer (buffer-name)
    (add-to-list 'display-buffer-alist
                 `(,buffer-name (display-buffer-reuse-window display-buffer-in-side-window)
                                (side . bottom)
                                (slot . 0)
                                (window-parameters . ((no-delete-other-windows . t)))
                                (window-height . 25)
                                (preserve-size . (nil . t)))))
#+end_src

*** Compilation buffer on bottom

#+begin_src emacs-lisp
  (nuance/display-buffer-in-bottom-drawer "*compilation*")
  (nuance/display-buffer-in-bottom-drawer "*detached-compilation*")
  (nuance/display-buffer-in-bottom-drawer "*Messages*")
#+end_src

** Easy async-shell-command

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c x") #'with-editor-async-shell-command)
#+end_src

* UI Appearance
** UI Interaction

#+BEGIN_SRC emacs-lisp
  (if (boundp 'use-short-answers)
      (setq use-short-answers t)
    (advice-add 'yes-or-no-p :override #'y-or-n-p))
  (setq apropos-do-all t
        echo-keystrokes 0.1               ; Show keystrokes asap
        inhibit-startup-message t         ; No splash screen please
        initial-scratch-message nil       ; Clean scratch buffer
        initial-major-mode 'emacs-lisp-mode)
#+END_SRC

** Bell

#+BEGIN_SRC emacs-lisp
  (setq visible-bell t
        inhibit-startup-echo-area-message t)

  (use-package mode-line-bell
    :demand t
    :config (mode-line-bell-mode))
#+END_SRC

** Cursor

#+BEGIN_SRC emacs-lisp
  (setq cursor-type 'hbar)
  (blink-cursor-mode 0)
#+END_SRC

** Scrolling

#+begin_src emacs-lisp
  (unless (eq (window-system) 'mac)
    (if (boundp 'pixel-scroll-precision-mode)
        (pixel-scroll-precision-mode 1)))
#+end_src

** Highlight line
#+begin_src emacs-lisp
  (global-hl-line-mode t)
  (defun pulse-line (&rest _)
    "Pulse the current line."
    (pulse-momentary-highlight-one-line (point)))

  (dolist (command '(scroll-up-command scroll-down-command recenter-top-bottom other-window))
    (advice-add command :after #'pulse-line))
#+end_src

** Line spacing

#+begin_src emacs-lisp
  (setq line-spacing 0.1)
#+end_src

** Minimal UI

#+BEGIN_SRC emacs-lisp
  (if (boundp 'toggle-frame-fullscreen) (toggle-frame-fullscreen))
  (if (boundp 'scroll-bar-mode) (scroll-bar-mode 0))
  (if (boundp 'tool-bar-mode) (tool-bar-mode 0))
  (menu-bar-mode (if (eq system-type 'darwin) t 0))
  (modify-all-frames-parameters '((internal-border-width . 0)))
#+END_SRC

** Mode-line

Minimal mode-line.

#+begin_src emacs-lisp
  (use-package mood-line :hook (after-init . mood-line-mode))
#+end_src

Show isearch hit information in mode-line.

#+begin_src emacs-lisp
  (use-package anzu :config (global-anzu-mode t))
#+end_src

*** Mode-Line Buffer Name

#+begin_src emacs-lisp
  (use-package shrink-path
    :after mood-line
    :config

    (defun nuance/project-relative-shrunk-path (project path)
      (if (f-ancestor-of? (project-root project) path)
          (let*
              ((shrunk-path (split-string (shrink-path-file path) "/"))
               (project-root-size (length (split-string (project-root project) "/"))))
            (string-join (-slice shrunk-path project-root-size) "/"))
        (shrink-path-file path)))

    (defun nuance/buffer-name ()
      (cond
       ((and (project-current) (buffer-file-name)) (format "[%s] %s" (nuance/project-name (project-current)) (nuance/project-relative-shrunk-path (project-current) (buffer-file-name))))
       ((buffer-file-name) (shrink-path-file (buffer-file-name)))
       (t (buffer-name))))

    (defvar-local nuance/buffer-name--cache nil)
    (defun mood-line-segment-buffer-name ()
      (unless nuance/buffer-name--cache
        (set-variable 'nuance/buffer-name--cache (format "%s  " (nuance/buffer-name))))
      (propertize nuance/buffer-name--cache 'face 'mood-line-buffer-name)))
#+end_src

** Line numbering

#+begin_src emacs-lisp
  (use-package prog-mode
    :straight nil
    :custom ((display-line-numbers-width t))
    :hook ('prog-mode . #'display-line-numbers-mode))
#+end_src

** Rainbow delimiters

#+begin_src emacs-lisp
  (use-package rainbow-delimiters :hook (prog-mode . rainbow-delimiters-mode))
#+end_src

** Matching parens highlight

#+BEGIN_SRC emacs-lisp
  (show-paren-mode)
#+END_SRC

** Terminal Title

#+begin_src emacs-lisp
  (defun nuance/osc-command (code body)
    (when (not (or noninteractive (window-system)))
      (let ((cmd (concat "\033]" code  ";" body "\007")))
        (send-string-to-terminal cmd))))

  (defun nuance/xterm-title-update ()
    (nuance/osc-command "2" (format-mode-line frame-title-format)))

  (defun nuance/xterm-bg-update (color)
    (nuance/osc-command "11" color))

  (add-hook 'post-command-hook 'nuance/xterm-title-update)
#+end_src

** Light / Dark theme toggle
I'd like to toggle between light & dark themes.

#+BEGIN_SRC emacs-lisp
  (defvar nuance/after-theme-change-hook nil "Hook called after theme has changed")

  (use-package doom-themes
    :config
    (defvar light-theme 'doom-solarized-light)
    (defvar dark-theme 'doom-rouge)

    (defvar nuance/current-theme 'light)
    (add-to-list 'savehist-additional-variables 'nuance/current-theme)

    (defun nuance/apply-theme (appearance)
      "Load theme, taking current system APPEARANCE into consideration."
      (mapc #'disable-theme custom-enabled-themes)
      (run-hooks 'nuance/after-theme-change-hook)
      (pcase appearance
        ('light (load-theme light-theme t) (nuance/xterm-bg-update "#ffffff"))
        ('dark (load-theme dark-theme t) (nuance/xterm-bg-update "#010000"))))

    (defun dark () (interactive) (setq nuance/current-theme 'dark) (nuance/apply-theme 'dark))
    (defun light () (interactive) (setq nuance/current-theme 'light) (nuance/apply-theme 'light))

    (add-hook 'ns-system-appearance-change-functions #'nuance/apply-theme)
    (nuance/apply-theme 'dark)
    :hook
    (mac-effective-appearance-change
     . (lambda ()
         (nuance/apply-theme
          (pcase (plist-get (mac-application-state) :appearance)
            ("NSAppearanceNameDarkAqua" 'dark)
            ("NSAppearanceNameAqua" 'light))))))
#+END_SRC

*** Solaire

#+begin_src emacs-lisp
  (use-package solaire-mode
    :config (solaire-global-mode))
#+end_src

** Fonts

#+BEGIN_SRC emacs-lisp
  (setq nuance/font-size 100)

  (set-face-attribute 'default nil
                      :family "IBM Plex Mono"
                      :height nuance/font-size)
  (set-face-attribute 'fixed-pitch nil
                      :family "IBM Plex Mono")
  (set-face-attribute 'variable-pitch nil
                      :family "IBM Plex Sans")

  (set-face-attribute 'mode-line nil :height nuance/font-size)
  (set-face-attribute 'mode-line-inactive nil :height nuance/font-size);

  (use-package all-the-icons :if (display-graphic-p))
#+END_SRC

** Set titlebar color

#+BEGIN_SRC emacs-lisp
  (use-package ns-auto-titlebar
    :if (eq system-type 'darwin)
    :config
    (ns-auto-titlebar-mode))
#+END_SRC

** Mixed pitch

#+begin_src emacs-lisp
  (use-package mixed-pitch
    :hook (text-mode . mixed-pitch-mode))
#+end_src

* UI Interaction
** Helpers

#+begin_src emacs-lisp
  (defun dwim-default-text ()
    ;; Find a good default value for prompts
    (if (region-active-p) (buffer-substring (region-beginning) (region-end)) (thing-at-point 'symbol)))
#+end_src

** Minibuffer

#+begin_src emacs-lisp
  (setq nuance/completion-candidates 25)
#+end_src

*** Orderless

#+begin_src emacs-lisp
  (use-package orderless
    :init
    (setq completion-styles '(orderless)
          orderless-matching-styles '(orderless-prefixes)
          completion-category-defaults nil
          completion-category-overrides
          '((file (styles orderless))
            (consult-xref (styles orderless))
            (nuance/dynamic (styles . (basic)))
            (nuance/dynamic-file (styles . (basic))))))
#+end_src

*** Vertico

#+begin_src emacs-lisp
  (use-package vertico
    :straight (vertico :files (:defaults "extensions/*")
                       :includes (vertico-buffer vertico-directory))
    :init
    (vertico-mode)
    (unless (window-system) (vertico-buffer-mode))
    :custom
    (vertico-count nuance/completion-candidates)
    (vertico-resize t)
    (vertico-cycle t)
    (vertico-buffer-display-action '(display-buffer-in-side-window (window-height . 12) (side . top))))

  ;; A few more useful configurations...
  (use-package emacs
    :init
    ;; Do not allow the cursor in the minibuffer prompt
    (setq minibuffer-prompt-properties
          '(read-only t cursor-intangible t face minibuffer-prompt))
    (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

    ;; Emacs 28: Hide commands in M-x which do not work in the current mode.
    ;; Vertico commands are hidden in normal buffers.
    (setq read-extended-command-predicate #'command-completion-default-include-p)

    ;; Enable recursive minibuffers
    (setq enable-recursive-minibuffers t))
#+end_src

**** posframe

#+begin_src emacs-lisp
  (use-package vertico-posframe
    :config
    (vertico-posframe-mode 1)
    :custom
    (vertico-posframe-font "IBM Plex Mono 13")
    :custom-face
    (marginalia-documentation ((t (:inherit font-lock-doc-face :family "IBM Plex Sans")))))
#+end_src

*** Consult

#+begin_src emacs-lisp
  (use-package consult
    :demand t

    :bind (("s-o" . (lambda () (interactive) (consult-line (dwim-default-text))))
           ("s-i" . consult-imenu)
           ("s-O" . consult-imenu-multi)
           ("s-l" . consult-goto-line)
           ("s-t" . consult-buffer)
           ("M-y" . consult-yank-pop)
           ("<help> a" . consult-apropos))
    :custom ((consult-async-input-throttle 0.05)
             (consult-async-input-debounce 0.1)
             (consult-project-function nil))
    :init
    (fset 'multi-occur #'consult-multi-occur)
    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref))
#+end_src

*** Marginalia

#+begin_src emacs-lisp
  (use-package marginalia
    :custom (marginalias-max-relative-age 0) (marginalia-align 'right)
    :config
    (marginalia-mode)
    (setq marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light))
    (add-to-list 'marginalia-annotator-registry '(nuance/dynamic-file marginalia-annotate-file)))
#+end_src

*** All-the-icons-completion

#+begin_src emacs-lisp
  (use-package all-the-icons-completion
    :after (marginalia all-the-icons)
    :hook (marginalia-mode . all-the-icons-completion-marginalia-setup)
    :init
    (all-the-icons-completion-mode))
#+end_src

*** Embark

#+begin_src emacs-lisp
  (use-package embark
    :init (setq prefix-help-command #'embark-prefix-help-command)
    :bind
    ("C-." . embark-act)
    ("C-;" . embark-dwim)
    ("C-h b" . embark-bindings)
    ;; DWIM inside the minibuffer is pretty much always export
    (:map minibuffer-local-map ("C-;" . embark-export)))

  (use-package embark-consult
    :hook
    (embark-collect-mode . consult-preview-at-point-mode))
#+end_src

*** Dynamic completion helper

#+begin_src emacs-lisp
  (defun nuance/complete-dynamic (results-fn &optional category)
    "Construct a completion table with results from results-fn"
    (lambda (string predicate action)
      (pcase action
        (`(boundaries . ,suffix) `(boundaries . (0 . 0)))
        ('metadata `(metadata (category . ,(if category category 'nuance/dynamic))))
        (_ (apply results-fn (list string))))))
#+end_src

** Completion

*** Corfu

#+BEGIN_SRC emacs-lisp
  (use-package corfu
    :straight (corfu :files (:defaults "extensions/*")
                     :includes (corfu-popupinfo))
    :bind (:map corfu-map
                ("C-n" . corfu-next)
                ("C-p" . corfu-previous)
                ("<escape>" . corfu-quit)
                ("<return>" . corfu-insert)
                ("<tab>" . corfu-insert)
                ("SPC" . corfu-insert-separator)
                ("M-d" . corfu-popupinfo-toggle)
                ("C-g" . corfu-quit)
                ("M-l" . corfu-show-location)
                ("M-;" . corfu-move-to-minibuffer)
                ;; Scroll in the documentation window
                ("M-n" . corfu-popupinfo-scroll-up)
                ("M-p" . corfu-popupinfo-scroll-down))
    :custom
    ;; Works with `indent-for-tab-command'. Make sure tab doesn't indent when you
    ;; want to perform completion
    (tab-always-indent 'complete)
    (c-tab-always-indent 'complete)
    (completion-cycle-threshold nil)      ; Always show candidates in menu

    (corfu-auto t)
    (corfu-auto-prefix 0)
    (corfu-auto-delay 0)

    (corfu-min-width 80)
    (corfu-max-width 160)     ; Always have the same width
    (corfu-count 28)
    (corfu-scroll-margin 4)
    (corfu-cycle nil)

    (corfu-echo-documentation nil)        ; Already use corfu-doc
    (corfu-separator ?\s)                 ; Necessary for use with orderless
    (corfu-quit-no-match 'separator)

    (corfu-preview-current 'insert)       ; Preview current candidate?
    (corfu-preselect-first t)             ; Preselect first candidate?
    (corfu-popupinfo-delay 0.5)
    (corfu-popupinfo-max-width 70)
    (corfu-popupinfo-max-height 20)

    :init
    (global-corfu-mode)
    :config

    (defun corfu-move-to-minibuffer ()
      (interactive)
      (let ((completion-extra-properties corfu--extra)
            completion-cycle-threshold completion-cycling)
        (apply #'consult-completion-in-region completion-in-region--data)))

    ;; Enable Corfu more generally for every minibuffer, as long as no other
    ;; completion UI is active. If you use Mct or Vertico as your main minibuffer
    ;; completion UI. From
    ;; https://github.com/minad/corfu#completing-with-corfu-in-the-minibuffer
    (defun corfu-enable-always-in-minibuffer ()
      "Enable Corfu in the minibuffer if Vertico/Mct are not active."
      (unless (bound-and-true-p vertico--input)
        (setq-local corfu-auto nil)       ; Ensure auto completion is disabled
        (corfu-mode 1)))
    :hook ((minibuffer-setup . corfu-enable-always-in-minibuffer)
           (corfu-mode . corfu-popupinfo-mode)))
#+END_SRC

*** Kind icon

#+begin_src emacs-lisp
  (use-package kind-icon
    :demand t
    :if (not (eq (window-system) 'mac))
    :custom
    (kind-icon-use-icons t)
    (kind-icon-default-face 'corfu-default) ; Have background color be the same as `corfu' face background
    (kind-icon-blend-background nil)  ; Use midpoint color between foreground and background colors ("blended")?
    (kind-icon-blend-frac 0.08)

    :config
    (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter) ; Enable `kind-icon'

    :hook (nuance/after-theme-change . kind-icon-reset-cache))
#+end_src

** Default to regexp search

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :bind (("C-s" . 'isearch-forward-regexp)
           ("C-r" . 'isearch-backward-regexp)))
#+END_SRC

** Sublime-like
*** Don't create random files

#+begin_src emacs-lisp
  (setq make-backup-files nil
        auto-save-default nil)
#+end_src

*** Automatically add newlines at EOF
#+BEGIN_SRC emacs-lisp
  (setq require-final-newline t)
#+END_SRC

*** Disable tab indentation

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
#+END_SRC

*** Remove trailing whitespace

#+BEGIN_SRC emacs-lisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

*** Expand region

#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :bind (("s-h" . 'er/expand-region)
           ("s-H" . 'er/contract-region)))
#+END_SRC

*** Multiple cursors

#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :custom (mc/always-run-for-all t)
    :config
    (add-to-list 'mc/unsupported-minor-modes 'eldoc-mode)

    (defun nuance/mark-next-like-this-symbol (arg)
      (interactive "p")
      (if (region-active-p)
          (mc/mark-next-like-this arg)
        (mc--select-thing-at-point 'symbol)))
    (add-to-list 'mc--default-cmds-to-run-once 'nuance/mark-next-like-this-symbol)

    :bind (("s-L" . mc/edit-lines)
           ("C-c L" . mc/edit-lines)
           ("s-d" . nuance/mark-next-like-this-symbol)
           ("C-c d" . nuance/mark-next-like-this-symbol)
           ("s-D" . mc/mark-all-dwim)
           ("C-c D" . mc/mark-all-dwim)
           ("s-<mouse-1>" . mc/add-cursor-on-click)
           :map mc/keymap
           ("<return>" . nil)))
#+END_SRC

**** Phi-search
Incremental search thats multiple-cursors-friendly.

#+BEGIN_SRC emacs-lisp
  (use-package phi-search
    :after multiple-cursors
    :custom ((phi-search-case-sensitive 'guess)))

  (use-package phi-replace
    :straight nil
    :after phi-search
    :after multiple-cursors
    :bind (:map mc/keymap ([remap query-replace] . phi-replace-query)))
#+END_SRC

*** MWIM

#+begin_src emacs-lisp
  (use-package mwim
    :bind
    (("C-e" . mwim-end)
     ("C-a" . mwim-beginning)))
#+end_src

*** Comment line / region

#+BEGIN_SRC emacs-lisp
  (defun comment-line-or-region (beg end)
    "Comment a region or the current line."
    (interactive "*r")
    (save-excursion
      (if (region-active-p)
          (comment-or-uncomment-region beg end)
        (comment-line 1))))

  (global-set-key (kbd "C-\\") 'comment-line-or-region)
  (global-set-key (kbd "s-/") 'comment-line-or-region)
#+END_SRC

*** Select whole buffer

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "s-a") 'mark-whole-buffer)
#+END_SRC

*** Compilation mode tweaks

#+BEGIN_SRC emacs-lisp
  (use-package compile
    :straight nil
    :bind (("s-B" . compile) ("s-b" . recompile))
    :custom ((compilation-scroll-output t)))

  (use-package ansi-color
    :straight nil
    :config
    (defun colorize-compilation-buffer ()
      (read-only-mode)
      (ansi-color-apply-on-region compilation-filter-start (point))
      (read-only-mode))
    :hook ('compilation-filter . #'colorize-compilation-buffer))
#+END_SRC

*** Indent / Dedent
#+BEGIN_SRC emacs-lisp
  (defun dedent (start end)
    (interactive "*r")
    (indent-rigidly start end (- tab-width)))

  (defun indent (start end)
    (interactive "*r")
    (indent-rigidly start end tab-width))

  (global-set-key (kbd "s-[") 'dedent)
  (global-set-key (kbd "s-]") 'indent)
#+END_SRC

*** Guess indentation settings

#+BEGIN_SRC emacs-lisp
  (use-package dtrt-indent
    :config
    (dtrt-indent-mode 1))
#+END_SRC

*** Window navigation

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-j") 'previous-window)
  (global-set-key (kbd "M-k") 'other-window)

  (use-package emacs
    :config
    (defun nuance/window-order (a b)
      (let ((a-left (window-pixel-left a))
            (b-left (window-pixel-left b))
            (a-top (window-pixel-top a))
            (b-top (window-pixel-top b)))
        (if (= a-top b-top) (< a-left b-left) (< a-top b-top))))

    (defun switch-to-nth-window (window-num)
      (select-window (elt (sort (window-list) #'nuance/window-order) window-num)))
    :bind (
           ("s-1" . (lambda () (interactive) (switch-to-nth-window 0)))
           ("s-2" . (lambda () (interactive) (switch-to-nth-window 1)))
           ("s-3" . (lambda () (interactive) (switch-to-nth-window 2)))
           ("s-4" . (lambda () (interactive) (switch-to-nth-window 3)))
           ("s-5" . (lambda () (interactive) (switch-to-nth-window 4)))
           ("s-6" . (lambda () (interactive) (switch-to-nth-window 5)))
           ("s-7" . (lambda () (interactive) (switch-to-nth-window 6)))
           ("s-8" . (lambda () (interactive) (switch-to-nth-window 7)))
           ("s-9" . (lambda () (interactive) (switch-to-nth-window 8)))))
#+END_SRC

*** Upcase / downcase

#+BEGIN_SRC emacs-lisp
  (put 'upcase-region 'disabled nil)
  (put 'downcase-region 'disabled nil)
#+END_SRC

*** Electric pair

#+BEGIN_SRC emacs-lisp
  (electric-pair-mode 1)
#+END_SRC

*** Auto revert

#+BEGIN_SRC emacs-lisp
  (customize-set-variable 'global-auto-revert-not-file-buffers t)
  (global-auto-revert-mode t)
#+END_SRC

*** window management

Mimic standard macos window / tab management commands

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "s-w") 'kill-this-buffer)
  (global-set-key (kbd "s-W") (lambda () (interactive) (kill-this-buffer) (delete-window)))
  (global-set-key (kbd "s-N") 'make-frame)
  (global-set-key (kbd "s-W") 'delete-frame)
  (global-set-key (kbd "s-s") 'save-buffer)
#+END_SRC

#+begin_src emacs-lisp
  (winner-mode t)
  (global-set-key (kbd "C-c 0") 'winner-undo)
#+end_src

*** scratch

#+begin_src emacs-lisp
  (use-package ielm
    :config
    (defun nuance/ielm-init-history ()
      (let ((path (expand-file-name "ielm/history" user-emacs-directory)))
        (make-directory (file-name-directory path) t)
        (setq-local comint-input-ring-file-name path))
      (setq-local comint-input-ring-size 10000)
      (setq-local comint-input-ignoredups t)
      (comint-read-input-ring))

    (defun nuance/ielm-write-history (&rest _args)
      (with-file-modes #o600
        (comint-write-input-ring)))

    (advice-add 'ielm-send-input :after 'nuance/ielm-write-history)

    :hook (ielm-mode . nuance/ielm-init-history)
    :bind (("s-n" . ielm)
           :map ielm-map
           ("C-l" . comint-clear-buffer)
           ("C-r" . consult-history)))
#+end_src

** CTags

Auto-revert to new tags file
#+BEGIN_SRC emacs-lisp
  (setq tags-revert-without-query 1)
#+END_SRC

** vterm

#+BEGIN_SRC emacs-lisp
  (use-package vterm
    :demand t
    :hook (vterm-mode . goto-address-mode)
    :custom (vterm-max-scrollback 20000)
    :config
    (add-to-list 'vterm-eval-cmds '("update-pwd" (lambda (path) (setq default-directory path))))

    (defun project-vterm ()
      (interactive)
      (let* ((default-directory (project-root (project-current t)))
             (vterm-buffer-name (project-prefixed-buffer-name "vterm"))
             (vterm-buffer (get-buffer vterm-buffer-name)))
        (if (and vterm-buffer (not current-prefix-arg))
            (pop-to-buffer vterm-buffer (bound-and-true-p display-comint-buffer-action))
          (vterm))))

    ;; unbind function keys
    (cl-loop for num from 1 to 12 do (unbind-key (kbd (format "<f%d>" num)) vterm-mode-map))
    :bind (("s-T" . project-vterm)
           :map vterm-mode-map
           ("<wheel-up>" . (lambda () (interactive) (vterm-send-key "<up>")))
           ("<wheel-down>" . (lambda () (interactive) (vterm-send-key "<down>")))))
#+END_SRC

** eshell

#+begin_src elisp
  (setq eshell-prompt-regexp "^[^#$\n]*[#$] "
        eshell-prompt-function
        (lambda nil
          (concat
           (if (string= (eshell/pwd) (getenv "HOME"))
               "~" (eshell/basename (eshell/pwd)))
           (if (= (user-uid) 0) "#" "$")
           " ")))
#+end_src


** Scroll through errors

This is really poorly structured, but flymake doesn't provide a
next-error-function implementation, so define a wrapper that navigates
between both flymake & flycheck errors.

#+begin_src emacs-lisp
  (defun nuance/maybe-point (func)
    (let ((here (point)))
      (save-excursion (ignore-errors (call-interactively func)) (unless (eq (point) here) (point)))))

  (defun nuance/next-error ()
    (interactive)
    (let ((here (point))
          (points))
      (when (and (boundp 'flymake-mode) flymake-mode)
        (when-let ((p (nuance/maybe-point #'flymake-goto-next-error)))
          (push p points)))
      (when (and (boundp 'flycheck-mode) flycheck-mode)
        (when-let ((p (nuance/maybe-point #'flycheck-next-error)))
          (push p points)))
      (when-let ((p (nuance/maybe-point #'next-error)))
        (push p points))
      (unless (null points) (goto-char (apply 'min points)))))

  (defun nuance/previous-error ()
    (interactive)
    (let ((here (point))
          (points))
      (when (and (boundp 'flymake-mode) flymake-mode)
        (when-let ((p (nuance/maybe-point #'flymake-goto-prev-error)))
          (push p points)))
      (when (and (boundp 'flycheck-mode) flycheck-mode)
        (when-let ((p (nuance/maybe-point #'flycheck-previous-error)))
          (push p points)))
      (when-let ((p (nuance/maybe-point #'previous-error)))
        (push p points))
      (unless (null points) (goto-char (apply 'min points)))))

  (bind-key (kbd "M-n") 'nuance/next-error)
  (bind-key (kbd "M-p") 'nuance/previous-error)
#+end_src

** Show flymake errors

#+begin_src elisp
  (use-package flymake-diagnostic-at-point
    :hook (flymake-mode . flymake-diagnostic-at-point-mode))
#+end_src

** Project Navigation

#+begin_src emacs-lisp
  (use-package memoize)

  (use-package project
    :straight nil
    :config
    (defvar nuance/dotfiles-base-dir (expand-file-name "~/dotfiles"))
    (defvar nuance/dotfiles-dirs `(,nuance/dotfiles-base-dir ,(expand-file-name "~/.emacs.d") ,(expand-file-name "~/.config")))

    (defun project-find-dotfiles-dir (dir)
      (when (-any (lambda (p) (or (f-same? p dir) (f-ancestor-of? p dir))) nuance/dotfiles-dirs))
      (cons 'dotfiles-dir nuance/dotfiles-base-dir))
    (memoize 'project-find-dotfiles-dir)

    (cl-defmethod project-root ((project (head dotfiles-dir)))
      (cdr project))

    (cl-defmethod project-files ((project (head dotfiles-dir)) &optional dirs)
      "Implementation of `project-files' for dotfiles projects."
      (cl-mapcan
       (lambda (dir) (cl-call-next-method))
       (or dirs (project-roots project))))

    (add-hook 'project-find-functions #'project-find-dotfiles-dir)

    (cl-defgeneric nuance/project-name (project)
      "Return a nice version of the project name"
      (file-name-base (directory-file-name (file-local-name (project-root project)))))
    :bind (("s-," . (lambda () (interactive) (find-file (concat user-emacs-directory "init.org"))))
           ("s-<" . (lambda () (interactive) (find-file (concat user-emacs-directory "private.org"))))))
#+end_src

*** Find by name

#+begin_src emacs-lisp
  (use-package project
    :straight t
    :after (consult)

    :init
    (cl-defgeneric nuance/project-find-by-name-cmd (project q)
      (let* ((split (split-string q " " t))
             (pattern (format "(%s){%d}+" (s-join "|" (mapcar (lambda (s) (format "%s.*" s)) split)) (length split))))
        (format "fd --hidden --no-ignore --color=never --max-results=%d \"%s\" %s" (* 5 nuance/completion-candidates) pattern (project-root project))))

    (cl-defgeneric nuance/project-find-by-name-initial (project) "" nil "")

    (defvar nuance/find-by-name-history nil)
    (add-to-list 'savehist-additional-variables 'nuance/find-by-name-history)

    :config
    (defun nuance/find-by-name (prompt builder initial)
      (consult--read
       (consult--async-command builder
         (consult--async-map (lambda (x) (f-relative (concat (file-remote-p default-directory) (string-remove-prefix "./" x)) default-directory)))
         (consult--async-highlight builder)
         :file-handler t) ;; allow tramp
       :prompt prompt
       :sort nil
       :require-match t
       :initial (consult--async-split-initial initial)
       :add-history (consult--async-split-thingatpt 'filename)
       :category 'file
       :history '(:input nuance/find-by-name-history)))

    (defun nuance/find-by-name-builder (project input)
      "Build command line given INPUT."
      (pcase-let* ((cmd (nuance/project-find-by-name-cmd project input))
                   (`(,arg . ,opts) (consult--command-split input))
                   (`(,re . ,hl) (funcall consult--regexp-compiler arg 'basic t)))
        (when re
          (cons (split-string-and-unquote cmd) hl))))

    (defun project-find-file-in (filename dirs project &optional include-all)
      "Search for regexp with find in DIR with INITIAL input.
    The find process is started asynchronously, similar to `consult-grep'.
    See `consult-grep' for more details regarding the asynchronous search."
      (interactive "P")
      (let* ((default-directory (project-root project))
             (prompt (format "%s: " (nuance/project-name project)))
             (builder (lambda (input) (nuance/find-by-name-builder project input)))
             (initial (concat (nuance/project-find-by-name-initial project) (thing-at-point 'filename)))
             (path (nuance/find-by-name prompt builder initial)))
        (xref-push-marker-stack)
        (find-file path)))

    (defun nuance/find-in-dotfiles ()
      (interactive)
      (let ((default-directory "~/dotfiles")) (project-find-file)))

    :bind (("s-p" . project-find-file)))
#+end_src

*** Find by content

#+begin_src emacs-lisp
  (use-package project
    :straight t
    :after (consult)
    :init
    (cl-defgeneric nuance/find-by-content-dispatch (project) "" nil
                   (consult-git-grep))

    :config
    (defun nuance/find-by-content ()
      "Search for regexp with find in DIR with INITIAL input.
      The find process is started asynchronously, similar to `consult-grep'.
      See `consult-grep' for more details regarding the asynchronous search."
      (interactive)
      (nuance/find-by-content-dispatch (project-current)))

    :bind (("s-f" . nuance/find-by-content)))
#+end_src

** Custom xref definition

A simple xref backend using rg. Inspired by the gxref implementation.

#+begin_src emacs-lisp
  (require 'cl-lib)
  (require 'xref)

  (defun nuance/rg-xref--find-regexp (pattern)
    (let* ((project (project-current))
           (pr (project-root project))
           (default-directory pr)
           (matches (split-string
                     (shell-command-to-string (format "rg --vimgrep --max-columns %d --color=never -e '%s' | head -n %d" (frame-width) pattern (* 5 nuance/completion-candidates))) "\n" t)))
      (mapcar
       (lambda (m)
         (let* ((parts (split-string m ":"))
                (path (concat default-directory (car parts)))
                (line (string-to-number (cadr parts)))
                (column (1- (string-to-number (caddr parts)))))
           (xref-make m (xref-make-file-location path line column)))) matches)))

  (defun nuance/rg-xref-backend ()
    "My ripgrep + project.el xref backend"
    (when (project-current)
      'nuance/rg-xref))

  (cl-defmethod xref-backend-identifier-at-point ((_backend (eql nuance/rg-xref)))
    "Return the relevant identifier at point.

        The return value must be a string, or nil meaning no identifier
        at point found.

        If it's hard to determine the identifier precisely (e.g., because
        it's a method call on unknown type), the implementation can
        return a simple string (such as symbol at point) marked with a
        special text property which e.g. `xref-backend-definitions' would
        recognize and then delegate the work to an external process."
    (let ((current-symbol (symbol-at-point)))
      (when current-symbol
        (symbol-name current-symbol))))

  (defun nuance/rg-xref-definition-regexp (pattern)
    (format "(((def|class)\\s+%s[(:])|(\\b%s\\b.*\\s+=))" pattern pattern))

  (cl-defmethod xref-backend-definitions ((_backend (eql nuance/rg-xref)) ident)
    "Find definitions of IDENTIFIER.

            The result must be a list of xref objects.  If IDENTIFIER
            contains sufficient information to determine a unique definition,
            return only that definition. If there are multiple possible
            definitions, return all of them.  If no definitions can be found,
            return nil."
    (nuance/rg-xref--find-regexp (nuance/rg-xref-definition-regexp ident)))

  (cl-defmethod xref-backend-references ((_backend (eql nuance/rg-xref)) ident)
    "Find references of IDENTIFIER.
              The result must be a list of xref objects.  If no references can
              be found, return nil."
    (nuance/rg-xref--find-regexp (format "[^a-zA-Z0-9]%s[^a-zA-Z0-9]" ident)))

  (cl-defmethod xref-backend-apropos ((_backend (eql nuance/rg-xref)) pattern)
    "Find all symbols that match PATTERN string.
          The second argument has the same meaning as in `apropos'.

          If BACKEND is implemented in Lisp, it can use
          `xref-apropos-regexp' to convert the pattern to regexp."
    (nuance/rg-xref--find-regexp (nuance/rg-xref-definition-regexp pattern)))

  (cl-defmethod
    xref-backend-identifier-completion-table ((_backend (eql nuance/rg-xref)))
    "Return the completion table for identifiers.

                I haven't used this method directly before (it seems to only serve as an aid for prompts when there's no symbol at point), so this is a no-op for now."
    '())

  (add-to-list 'xref-backend-functions 'nuance/rg-xref-backend)
#+end_src

** Open links

#+begin_src emacs-lisp
  (use-package goto-addr
    :straight nil
    :bind ("C-c C-o" . goto-address-at-point))
#+end_src

** Operate on lines if no region set

#+begin_src emacs-lisp
  (use-package whole-line-or-region
    :config (whole-line-or-region-global-mode))
#+end_src

** Reload files

#+begin_src emacs-lisp
  (global-set-key (kbd "s-r") 'revert-buffer)
#+end_src

** Casing

#+begin_src emacs-lisp
  (use-package string-inflection
    :bind (:map prog-mode-map ("C-c i" . string-inflection-cycle)))
#+end_src

** Terminal Mouse

#+begin_src emacs-lisp
  (when (not (window-system)) (xterm-mouse-mode))
#+end_src

** MacOS links

#+begin_src emacs-lisp
  (defun nuance/chrome-url-title ()
    (let*
        ((applescript (concat
                       "tell application \"Chrome\"\n"
                       " set theUrl to get URL of active tab of first window\n"
                       " set theTitle to get title of active tab of first window\n"
                       " return (get theUrl) & \"::split::\" & theTitle\n"
                       "end tell\n"))
         (raw-result (do-applescript applescript))
         (split (split-string (substring raw-result 1 -1) "::split::")))
      (cons (elt split 0) (elt split 1))))
#+end_src

** Tabs

#+begin_src emacs-lisp
  (global-set-key (kbd "s-}") 'tab-next)
  (global-set-key (kbd "s-{") 'tab-previous)
  (global-set-key (kbd "C-x T") 'tab-switch)
#+end_src

** Global Mark Ring

#+begin_src emacs-lisp
  (setq global-mark-ring-max 1024)
  (global-set-key (kbd "s-.") #'consult-global-mark)
#+end_src

* Packages
** Magit
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :commands magit-status magit-blame-addition
    :custom ((magit-branch-arguments nil)
             ;; don't put "origin-" in front of new branch names by default
             (magit-default-tracking-name-function 'magit-default-tracking-name-branch-only)
             (magit-push-always-verify nil)
             ;; Get rid of the previous advice to go into fullscreen
             (magit-restore-window-configuration t)
             (git-commit-fill-column 120))
    :init
    (cl-defgeneric nuance/status (project)
      (magit-status (project-root project)))
    :bind ("C-x g" . (lambda () (interactive) (nuance/status (project-current)))))
#+end_src

** Diff Highlight
#+BEGIN_SRC emacs-lisp
  (use-package diff-hl

    :config
    (global-diff-hl-mode)
    (diff-hl-margin-mode)
    (global-diff-hl-amend-mode)
    (global-diff-hl-show-hunk-mouse-mode)
    (diff-hl-flydiff-mode))
#+END_SRC

** Ediff

#+begin_src emacs-lisp
  (use-package ediff
    :custom ((ediff-window-setup-function 'ediff-setup-windows-plain)))
#+end_src

** Snippets

#+begin_src emacs-lisp
  (use-package tempel
    :demand t
    :init
    (defun tempel-setup-capf () (setq-local completion-at-point-functions (cons #'tempel-complete completion-at-point-functions)))
    :bind (:map tempel-map ("TAB" . tempel-next))
    :hook ((prog-mode . tempel-setup-capf)
           (text-mode . tempel-setup-capf)))
#+end_src

#+begin_src emacs-lisp :tangle ~/.emacs.d/templates
  ;; -*- mode: lisp -*-

  org-mode

  (quote "#+begin_quote" n> r> n> "#+end_quote")
  (example "#+begin_example" n> r> n> "#+end_example")
  (center "#+begin_center" n> r> n> "#+end_center")
  (comment "#+begin_comment" n> r> n> "#+end_comment")
  (verse "#+begin_verse" n> r> n> "#+end_verse")
  (src "#+begin_src " p n> r> n> "#+end_src")
  (task "*************** TODO " p n>)
  (elisp "#+begin_src emacs-lisp" n> r> n "#+end_src"
         :post (progn (tempel-done) (org-edit-src-code)))
#+end_src

*** yasnippet

Include yasnippet for eglot usage.

#+begin_src emacs-lisp
  (use-package yasnippet
    :hook (prog-mode . yas-minor-mode))
#+end_src

** LSP
#+BEGIN_SRC emacs-lisp
  (use-package eglot

    :config
    (setq-default
     eglot-workspace-configuration '((:gopls . ((usePlaceholders . t)
                                                (allExperiments . t)
                                                (staticcheck . t)
                                                (analyses . (
                                                             (nilness . t)
                                                             (fieldalignment . t)
                                                             (shadow . t)
                                                             (unusedparams . t)
                                                             (unusedwrite . t)))
                                                (matcher . "Fuzzy"))))
     eglot-events-buffer-size 0)

    (defun nuance/eglot-organize-imports ()
      (ignore-errors (eglot-code-action-organize-imports (point-min))))

    ;; Optional: install eglot-format-buffer as a save hook.
    ;; The depth of -10 places this before eglot's willSave notification,
    ;; so that that notification reports the actual contents that will be saved.
    (defun nuance/eglot-format-buffer-on-save ()
      (add-hook 'before-save-hook (lambda () (unless nuance/skip-format-on-save (nuance/eglot-organize-imports))) -11 t)
      (add-hook 'before-save-hook (lambda () (unless nuance/skip-format-on-save (eglot-format-buffer))) -10 t))

    (define-minor-mode nuance/skip-format-on-save
      "Don't call eglot format / organize imports when enabled")
    (defun eglot-rename
        (newname)
      "Rename the current symbol to NEWNAME."
      (interactive
       (list
        (read-from-minibuffer
         (format "Rename `%s' to: "
                 (or
                  (thing-at-point 'symbol t)
                  "unknown symbol"))
         (thing-at-point 'symbol t) nil nil nil
         (symbol-name
          (symbol-at-point)))))
      (eglot-server-capable-or-lose :renameProvider)
      (eglot--apply-workspace-edit
       (eglot--request (eglot--current-server-or-lose)
                       :textDocument/rename `(,@(eglot--TextDocumentPositionParams)
                                              :newName ,newname))
       this-command))

    :hook
    (((python-mode c++-mode c-mode go-mode rust-mode) . eglot-ensure)
     (eglot-managed-mode . nuance/eglot-format-buffer-on-save))
    :bind (:map eglot-mode-map
                ("C-c r" . eglot-rename)
                ("C-c f" . eglot-format)
                ("C-c a" . eglot-code-actions)))
#+END_SRC

** Org
*** Installation

#+begin_src emacs-lisp
  (use-package org
    :demand t
    :custom ((org-special-ctrl-a/e t)
             (org-startup-folded t)
             (org-pretty-entities t)
             (org-src-tab-acts-natively t)
             (org-src-window-setup 'plain)
             (org-element-use-cache nil)
             (org-element-cache-persistent nil))
    :config (setq org-capture-templates '())

    (defun nuance/store-chrome-link ()
      (interactive)
      (pcase-let ((`(,link . ,desc) (nuance/chrome-url-title)))
        (unless (member (list link desc) org-stored-links)
          (push (list link desc) org-stored-links))))

    (setq org-refile-targets
          `((nil :maxlevel . 9)
            (,(directory-files-recursively "~/org" "^[^.].*[.]org$") :maxlevel . 3)
            (org-agenda-files :maxlevel . 3)))
    (setq org-outline-path-complete-in-steps nil)
    (setq org-refile-use-outline-path 'file)
    :hook
    ((org-mode . visual-line-mode)
     (org-mode . (lambda ()
                   (org-content 2)
                   (define-key org-mode-map (kbd "C-c g") 'nuance/store-chrome-link)))
     (before-save . (lambda () (when (eq major-mode 'org-mode) (indent-region (buffer-end -1) (buffer-end 1))))))
    :bind
    (("C-c c" . org-capture)
     ("C-c l" . org-store-link)))
#+end_src

*** org-nvalt

My personal take on an nvalt replacement in emacs / org-mode.

cmd-k - find or create a note (global)
cmd-l - insert a link to note (creating a note if it doesn't currently exist; wrapping the region with the link if it is active) (org-mode)

#+begin_src emacs-lisp
  (defvar nuance/nv-notes-dir "~/org/nv" "Location to store notes")

  (defun nuance/nv--notes-path () "Absolute path to notes location" (expand-file-name nuance/nv-notes-dir))

  (defun nuance/nv--note-path
      (name)
    (f-join default-directory
            (concat
             (replace-regexp-in-string " +" "_"
                                       (downcase name))
             ".org")))

  (defun nuance/nv--create-note (name) "Find or create a note based on a match string."
         ;; create a new file using the default template
         (let ((path (nuance/nv--note-path name)))
           (find-file path)
           (insert (format "#+TITLE: %s\n" (capitalize name)))
           (org-time-stamp '(16))
           (insert "\n\n")
           (org-mode)
           (auto-save-mode)
           path))

  (defun nuance/nv--find-note (prompt)
    (let* ((default-directory (file-name-directory (nuance/nv--notes-path)))
           (selection (completing-read
                       (concat prompt ": ")
                       (nuance/complete-dynamic
                        (lambda (q)
                          (let* ((tokens (split-string q " " t))
                                 (pattern (format "((%s).*){%d}" (s-join "|" tokens) (length tokens)))
                                 (cmd (format "rg --vimgrep --max-columns %d --color=never --smart-case '%s' | head -n %d" (* 10 (frame-width)) pattern (* 5 nuance/completion-candidates)))
                                 (results (shell-command-to-string cmd)))
                            (append (list q) (split-string results "\n" t)))))
                       nil nil (dwim-default-text)))
           (parts (split-string selection ":")))
      (if (length> parts 1)
          ;; open the requested file / line / col and unfold at point
          (let ((path (f-join default-directory (car parts)))
                (line (string-to-number (cadr parts)))
                (column (string-to-number (caddr parts))))
            `(t . (,path ,line ,column)))
        `(nil . (,selection)))))

  (defun nuance/nv-find-note ()
    "Find or create a note."
    (interactive)
    (let* ((default-directory (nuance/nv--notes-path))
           (selection (nuance/nv--find-note "nv")))
      (if (car selection)
          ;; open the requested file / line / col and unfold at point
          (let ((path (cadr selection))
                (line (caddr selection))
                (column (cadddr selection)))
            (find-file path)
            (goto-char (point-min))
            (forward-line (1- line))
            (forward-char (1- column))
            ;; expose the current node if we're in a (potentially folded) outline / org file
            (when (derived-mode-p 'outline-mode) (outline-show-entry)))
        (nuance/nv--create-note (cadr selection)))))

  (defun nuance/nv-daily-note () "Find or create a daily note."
         (interactive)
         (let*
             ((default-directory (f-join (nuance/nv--notes-path) "daily"))
              (date (format-time-string "%Y-%m-%d"))
              (path (nuance/nv--note-path date)))
           (if
               (file-exists-p path)
               (find-file path)
             (nuance/nv--create-note date))))

  (require 'calendar)

  (defun nuance/nv--subtract-days (date days)
    "Subtract DAYS from DATE."
    (calendar-gregorian-from-absolute (- (calendar-absolute-from-gregorian date) days)))

  (defun nuance/nv--format-date-iso (date)
    "Format a DATE in YYYY-MM-DD format."
    (format "%04d-%02d-%02d" (nth 2 date) (nth 0 date) (nth 1 date)))

  (defun nuance/nv--dates-from-range (start-date end-date)
    "Returns a list of dates (as strings) between the provided calendar dates."
    (let* ((num-days (1+ (- (calendar-absolute-from-gregorian end-date) (calendar-absolute-from-gregorian start-date))))
           (dates-list '()))
      (dotimes (i num-days dates-list)
        (push (nuance/nv--format-date-iso (calendar-gregorian-from-absolute (+ (calendar-absolute-from-gregorian start-date) i))) dates-list))
      (nreverse dates-list)))

  (defun nuance/nv--dates-of-previous-week ()
    "Returns a list of dates (as strings) for the previous week in YYYY-MM-DD format."
    (let* ((current-date (calendar-current-date))
           (current-day-of-week (calendar-day-of-week current-date))
           (start-of-week (nuance/nv--subtract-days current-date (+ current-day-of-week 7)))
           (end-of-week (nuance/nv--subtract-days current-date (1+ current-day-of-week))))
      (nuance/nv--dates-from-range start-of-week end-of-week)))

  (defun nuance/nv--daily-notes (dates)
    "Returns a list of paths of notes from the provided date range."
    (let* ((paths (mapcar #'nuance/nv--note-path dates))
           (notes (seq-remove (lambda (path) (not (file-exists-p path))) paths)))
      notes))

  (defun nuance/nv--last-week-notes-prompt ()
    "Returns a llm prompt containing the bodies of the last week of notes."
    (let* ((note-bodies (with-temp-buffer
                          (dolist (path (nuance/nv--daily-notes (nuance/nv--dates-of-previous-week)))
                            (insert-file-contents path))
                          (buffer-string)))
           (preamble "Given notes from the last week, taken in emacs org mode, starting with BEGIN_NOTES and ending with END_NOTES.\nBEGIN_NOTES\n")
           (postnote "END_NOTES\n\nWrite an org mode summary of up to ten things accomplished last week and a recommendation of up to ten things to accomplish this week. Don't provide any extra information or justification for each item (e.g. just a title is fine). Title the last week section 'Last Week' and this week section 'This Week'. Provide references to the date associated with each accomplishment from last week."))
      (s-concat preamble note-bodies postnote)))

  (defun nuance/nv--date-range-notes-prompt (start-date end-date)
    "Returns a llm prompt containing the bodies of the requested date range."
    (let* ((note-bodies (with-temp-buffer
                          (dolist (path (nuance/nv--daily-notes (nuance/nv--dates-from-range start-date end-date)))
                            (insert-file-contents path))
                          (buffer-string)))
           (preamble (s-concat "Given notes from the range " (nuance/nv--format-date-iso start-date) " to " (nuance/nv--format-date-iso end-date) ", taken in emacs org mode, starting with BEGIN_NOTES and ending with END_NOTES.\nBEGIN_NOTES\n"))
           (postnote "END_NOTES\n\nWrite an org mode summary of the most important up to ten things accomplished in this date range and a recommendation of the next up to ten things to accomplish. Don't provide any extra information or justification for each item (e.g. just a title is fine). Title the accomplished section 'Previously' and this week section 'Next'. Provide references to the date associated with each accomplishment."))
      (s-concat preamble note-bodies postnote)))

  (defun nuance/nv--weekly-note-name nil "Returns a string representing the current week in the format YYYY-Qq-ww."
         (let*
             ((date-info (decode-time (current-time)))
              (year (nth 5 date-info))
              (month (nth 4 date-info))
              (day (nth 3 date-info))
              (quarter (1+ (floor (/ month 3))))
              (week (1+ (/ (- (+ day (- (calendar-day-of-week date-info) 1)) 1) 7))))
           (format "%d-Q%d-%02d" year quarter week)))
  (defun nuance/nv-weekly-note ()
    "Find or create a weekly note for a given date."
    (interactive)
    (let*
        ((default-directory (f-join (nuance/nv--notes-path) "weekly"))
         (name (nuance/nv--weekly-note-name))
         (path (nuance/nv--note-path name)))
      (if
          (file-exists-p path)
          (find-file path)
        (nuance/nv--create-note name))))

  (defun nuance/nv-link-note ()
    "Insert a link to a note, creating the note if it currently does not exist. Title is either the current region or the name of the note."
    (interactive)
    (let* ((default-directory (nuance/nv--notes-path))
           (selection (nuance/nv--find-note "link"))
           (target (if (car selection) (cdr selection) (list (save-window-excursion (nuance/nv--create-note selection)) 0 0)))
           (link (format "%s::%d" (car target) (cadr target)))
           (title (file-name-base (car target))))
      (if (region-active-p)
          (progn (kill-region (region-beginning) (region-end)) (insert (format "[[%s][" link)) (yank) (insert "]]"))
        (insert (format "[[%s][%s]]" link title)))))

  (defun nuance/nv-chat-note ()
    "Prompt for context notes and start a chat session with context notes + prompt, inserting at current point as a quote."
    (interactive)
    (let* ((default-directory (nuance/nv--notes-path))
           (selection (nuance/nv--find-note "link"))
           (context "")
           (current-note "")
           (prompt (read-from-minibuffer "prompt: "))
           (success-fn (lambda (response) (insert (format "#+BEGIN_QUOTE\n%s\n#+END_QUOTE" response))))
           (failure-fn (lambda (response) (message "failure: %s" response))))
      (llm-chat-async nuance/llm-provider (llm-make-simple-chat-prompt (format "Given org-mode context `%s` and the current note (in org-mode) `%s`, generate markdown-formatted output to the prompt `%s`" context current-note prompt)) success-fn failure-fn)))

  (global-set-key (kbd "s-k") 'nuance/nv-find-note)
  (global-set-key (kbd "s-K") 'nuance/nv-daily-note)
  (add-hook 'org-mode-hook (lambda () (define-key org-mode-map (kbd "s-l") 'nuance/nv-link-note)))
  (add-hook 'org-mode-hook (lambda () (define-key org-mode-map (kbd "s-e") 'nuance/nv-chat-note)))
#+end_src

*** org-nvalt redux

**** brainstorming
Types of notes:
- named notes
- dated notes (corresponding to a day, a week, a month, a quarter etc.)
- dialogs (a note with org-babel blocks containing responses, with links to context notes at the start)

Notes are freeform org mode, so they can contain tags, links etc.

org-babel blocks are used to chat inside a note at any point - the llm should receive the note, any linked notes, and the conversation up to that point

Entrypoints:
- navigate by name
- navigate by search (matching on text / embedding etc.)
- navigate by date range (matching all notes with dates overlapping with the query range)

=> these are all the same, eg all navigating on text, text could be "note title," "note contents," "description,"  or "<date>"

basic commands:
- s-k: search notes (supports embark, defaults to region if selected, opens link at point if in a link)
- s-l: insert reference (generates link on region)
- s-e: llm superpower: chat with note (and possibly linked notes?). if in consult, chat with selected note(s).

Creating a new note should follow customizable templates:
- all notes should have a title and creation date (defaulting to today, but could be the date associated with the note if it's a dated note). The filename should be the title (as filenames are basically unimportant).
- a hook for populating the body of the note; e.g. a new weekly retro note should be able to query a llm to generate a body based on the notes from that week.

Should visiting a note tag it with a visit date?
Should editing to a note tag it with an edit date?

interactive entrypoints:
- search notes (s-k)
  - (0) create a new note (default options: named, today, last week)
  - (1) select an existing note to navigate to it
  - (2) initiate chat with results or selection (s-e) (triggers dialog note creation)
- insert reference (s-l) - triggers search, result is inserted into buffer rather than visited, if a new note is created open it otherwise remain
- insert dialog (s-e) - inserts an appropriately constructed org-babel block; trigger the dialog

**** ux sketch

#+begin_src elisp :tangle no
  (defun nuance/nv2--create-note (name &optional after-create-fn)
    "Create a new note with an optional callback.")

  (defun nuance/nv2--make-result (path title snippet)
    `(,path ,title ,snippet))

  (defun nuance/nv2--result-path (note)
    (nth 0 note))

  (defun nuance/nv2--result-title (note)
    (nth 1 note))

  (defun nuance/nv2--result-snippet (note)
    (nth 2 note))

  (defun nuance/nv2--execute-search (text)
    "Return a list of nuance/nv2--result.
      Query syntax:
       'text' - match text
       ':text' - match embedding
       '<date>' - match dates
    "
    `(,text ,text ,text))

  (defun nuance/nv2--query ()
    "Run a query session, returning zero or one result."
    (completing-read
     ": "
     (nuance/complete-dynamic #'nuance/nv2--execute-search)
     nil
     nil
     (dwim-default-text)))

  (defun nuance/nv2-navigate ()
    "Display a filterable list of notes."
    (interactive)
    (let ((selection (nuance/nv2--query)))
      selection))

  (defun nuance/nv2-refer ()
    "Insert a reference to the result of a search."
    (interactive)
    (if-let ((note (nuance/nv2--query)))
        (insert "[[" (nuance/nv2--result-title note) "]]")))

  (defun nuance/nv2-discuss ()
    "Insert a chat block in an existing note."
    (interactive)
    (insert "CHAT END_CHAT"))

  (global-set-key (kbd "C-c k") #'nuance/nv2-navigate)
  (global-set-key (kbd "C-c l") #'nuance/nv2-refer)
  (global-set-key (kbd "C-c e") #'nuance/nv2-discuss)
#+end_src
** LLM

*** ollama

#+begin_src emacs-lisp
  (use-package llm
    :config
    (require 'llm-ollama)
    (setq nuance/llm-provider (make-llm-ollama :chat-model "gemma:7b-instruct" :embedding-model "gemma:7b-instruct")))
#+end_src

** Tramp

#+BEGIN_SRC emacs-lisp
  (use-package tramp
    :straight nil
    :custom
    ((tramp-inline-compress-start-size (* 64 1024))
     (tramp-default-method "ssh")
     (tramp-terminal-type "tramp")
     (remote-file-name-inhibit-locks t))
    :config
    (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
#+END_SRC

** GC Magic Hack

Optimize GC usage

#+BEGIN_SRC emacs-lisp
  (use-package gcmh :config (gcmh-mode t))
#+END_SRC

** ElDoc

#+BEGIN_SRC emacs-lisp
  (use-package eldoc :hook ((prog-mode org-mode) . eldoc-mode))
  (use-package eldoc-box :hook ((prog-mode org-mode) . eldoc-box-hover-mode))
#+END_SRC

** which-key

#+begin_src emacs-lisp
  (use-package which-key
    :config (which-key-mode))
#+end_src

** Helpful

#+begin_src emacs-lisp
  (use-package helpful

    :bind (
           ([remap describe-function] . 'helpful-callable)
           ([remap describe-variable] . 'helpful-variable)
           ([remap describe-key] . 'helpful-key)
           ([remap describe-command] . 'helpful-command)
           ([remap describe-symbol] . 'helpful-symbol)
           ("C-h F" . 'helpful-function)
           ("C-c C-d" . 'helpful-at-point)
           ("C-h C" . 'helpful-command)
           :map helpful-mode-map ([remap revert-buffer] . 'helpful-update)))
#+end_src

*** elisp-demos

#+begin_src emacs-lisp
  (use-package elisp-demos
    :after helpful
    :config
    (advice-add 'helpful-update :after #'elisp-demos-advice-helpful-update))
#+end_src

** Visual undo

#+begin_src emacs-lisp
  (use-package vundo
    :custom (vundo-glyph-alist vundo-unicode-symbols)
    :bind ("C-c v" . vundo))
#+end_src

* File-type support
** Toggleable function narrowing

#+BEGIN_SRC emacs-lisp
  (defun nuance/toggle-narrow-to-defun ()
    (interactive)
    (if (buffer-narrowed-p) (widen) (narrow-to-defun)))

  (defun nuance/toggle-narrow-to-defun-or-region  (beg end)
    "Narrow to a region or the current function."
    (interactive "*r")
    (if (buffer-narrowed-p) (widen) (if (region-active-p) (narrow-to-region beg end) (narrow-to-defun))))

  (put 'narrow-to-region 'disabled nil)
#+END_SRC

** JSON

#+BEGIN_SRC emacs-lisp
  (use-package json-mode
    :mode "\\.json\\'")
#+END_SRC

** YAML
#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :mode "\\.yml\\'")
#+END_SRC

** Protobuf

#+BEGIN_SRC emacs-lisp
  (use-package protobuf-mode)
#+END_SRC

** C++

#+BEGIN_SRC emacs-lisp
  (use-package cc-mode
    :straight nil
    :config
    (defun my/c-indent-complete ()
      (interactive)
      (let ((p (point)))
        (c-indent-line-or-region)
        (when (= p (point))
          (call-interactively 'complete-symbol))))
    :mode ("\\.h|\\.cpp" . c++-mode)
    :bind (:map c-mode-base-map ("TAB" .  my/c-indent-complete)))
#+END_SRC

** Python

#+BEGIN_SRC emacs-lisp
  (use-package python)
#+END_SRC

** Rust

#+BEGIN_SRC emacs-lisp
  (use-package rust-mode)
#+END_SRC

** Go

#+BEGIN_SRC emacs-lisp
  (use-package go-mode)
#+END_SRC

** Bazel

#+BEGIN_SRC emacs-lisp
  (use-package bazel
    :mode ("'BUILD'" "'WORKSPACE'" "\\.bzl\\'" "'TARGETS'")
    :custom
    ((bazel-mode-buildifier-before-save t)
     (bazel-mode-buildifier-command "~/go/bin/buildifier"))
    :config
    (remove-hook 'project-find-functions #'bazel-find-project))
#+END_SRC

** Markdown

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :commands (markdown-mode gfm-mode)
    :mode (("README\\.md\\'" . gfm-mode)
           ("\\.md\\'" . markdown-mode)
           ("\\.markdown\\'" . markdown-mode))
    :init (setq markdown-command "multimarkdown"
                markdown-header-scaling t
                markdown-hide-urls t
                markdown-marginalize-headers nil
                markdown-marginalize-headers-margin-width 4
                markdown-fontify-code-blocks-natively t)
    :hook
    (('markdown-mode .'variable-pitch-mode)
     ('markdown-mode . 'visual-line-mode)))

  (use-package edit-indirect)
#+END_SRC

** treesit
#+begin_src emacs-lisp
  (use-package treesit
    :straight nil
    :preface
    (defun mp-setup-install-grammars ()
      "Install Tree-sitter grammars if they are absent."
      (interactive)
      (dolist (grammar
               '((c . ("https://github.com/tree-sitter/tree-sitter-c"))
                 (cpp . ("https://github.com/tree-sitter/tree-sitter-cpp"))
                 (go . ("https://github.com/tree-sitter/tree-sitter-go"))
                 (python . ("https://github.com/tree-sitter/tree-sitter-python"))))
        (add-to-list 'treesit-language-source-alist grammar)
        (unless (treesit-language-available-p (car grammar))
          (treesit-install-language-grammar (car grammar)))))

    (dolist (mapping '((c-mode . c-ts-mode)
                       (c++-mode . c++-ts-mode)
                       (go-mode . go-ts-mode)
                       (python-mode . python-ts-mode)))
      (add-to-list 'major-mode-remap-alist mapping))

    :config
    (mp-setup-install-grammars))
#+end_src

#+begin_src emacs-lisp :tangle no
  ;; `M-x combobulate' (or `C-c o o') to start using Combobulate
  (use-package combobulate
    :straight '(combobulate :type git :host github :repo "mickeynp/combobulate")
    :hook ((python-ts-mode . combobulate-mode)))
#+end_src
* Private.el
I'd like to keep a few settings private, so we load a =private.el= if it exists after the init-file has loaded.

#+BEGIN_SRC emacs-lisp
  (let ((private-file (concat user-emacs-directory "private.el"))
        (straight-current-profile 'private))
    (when (file-exists-p private-file)
      (load-file private-file)))
#+END_SRC

* Startup
Launch a server if not currently running.

#+BEGIN_SRC emacs-lisp
  (setq server-use-tcp t)
  (setq server-port 42069)
  (setq server-auth-key "emacskeyemacskeyemacskeyemacskeyemacskeyemacskeyemacskeyemacskey")

  (when (not noninteractive) (server-start))
#+END_SRC
