#+TITLE: Emacs configuration file
#+AUTHOR: Matthew Jones
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle yes

* About

   My emacs config, heavily inspired / forked from [[https://github.com/larstvei/dot-emacs]].

* Configurations
** Meta

   All changes to the configuration should be done in =init.org=, *not* in
   =init.el=. Any changes in the =init.el= will be overwritten by saving
   =init.org=. The =init.el= in this repo should not be tracked by git, and
   is replaced the first time Emacs is started (assuming it has been renamed
   to =~/.emacs.d=).

   Emacs can't load =.org=-files directly, but =org-mode= provides functions
   to extract the code blocks and write them to a file. There are multiple
   ways of handling this; like suggested by [[http://emacs.stackexchange.com/questions/3143/can-i-use-org-mode-to-structure-my-emacs-or-other-el-configuration-file][this StackOverflow post]], one
   could just use =org-babel-load-file=, but I had problems with
   byte-compilation. Previously I tracked both the =org.=- and =el.=-files,
   but the git commits got a little messy. So here is a new approach.

   When this configuration is loaded for the first time, the ~init.el~ is
   the file that is loaded. It looks like this:

   #+BEGIN_SRC emacs-lisp :tangle no
     ;; This file replaces itself with the actual configuration at first run.

     ;; We can't tangle without org!
     (require 'org)
     ;; Open the configuration
     (find-file (concat user-emacs-directory "init.org"))
     ;; tangle it
     (org-babel-tangle)
     ;; load it
     (load-file (concat user-emacs-directory "init.el"))
     ;; finally byte-compile it
     (byte-compile-file (concat user-emacs-directory "init.el"))
   #+END_SRC

   It tangles the org-file, so that this file is overwritten with the actual
   configuration.

   There is no reason to track the =init.el= that is generated; by running
   the following command =git= will not bother tracking it:

   #+BEGIN_SRC sh :tangle no
     git update-index --assume-unchanged init.el
   #+END_SRC

   If one wishes to make changes to the repo-version of =init.el= start
   tracking again with:

   #+BEGIN_SRC sh :tangle no
     git update-index --no-assume-unchanged init.el
   #+END_SRC

   I want lexical scoping for the init-file, which can be specified in the
   header. The first line of the configuration is as follows:

   #+BEGIN_SRC emacs-lisp :tangle no
     ;;; -*- lexical-binding: t -*-
   #+END_SRC

   The =init.el= should (after the first run) mirror the source blocks in
   the =init.org=. We can use =C-c C-v t= to run =org-babel-tangle=, which
   extracts the code blocks from the current file into a source-specific
   file (in this case a =.el=-file).

   To avoid doing this each time a change is made we can add a function to
   the =after-save-hook= ensuring to always tangle and byte-compile the
   =org=-document after changes.

   #+BEGIN_SRC emacs-lisp
     (defun tangle-init ()
       "If the current buffer is 'init.org' the code-blocks are
     tangled, and the tangled file is compiled."
       (when (or (equal (buffer-file-name)
		    (expand-file-name (concat user-emacs-directory "init.org")))
		 (equal (buffer-file-name)
		    (expand-file-name (concat user-emacs-directory "private.org"))))
	 ;; Avoid running hooks when tangling.
	 (let ((prog-mode-hook nil))
	   (org-babel-tangle)
	   ;; (byte-compile-file (concat user-emacs-directory "init.el"))
	   )))

     (add-hook 'after-save-hook 'tangle-init)
   #+END_SRC

   I sometimes want to exclude packages on certain machines, so load that.

   #+BEGIN_SRC emacs-lisp
     (setq package-overrides (make-hash-table))
     (let ((overrides-file (concat user-emacs-directory "config_overrides.el")))
       (when (file-exists-p overrides-file)
	 (load-file overrides-file)))
   #+END_SRC


   I'd like to keep a few settings private, so we load a =private.el= if it
   exists after the init-file has loaded.

   #+BEGIN_SRC emacs-lisp
     (add-hook
      'after-init-hook
      (lambda ()
	(let ((private-file (concat user-emacs-directory "private.el")))
	  (when (file-exists-p private-file)
	    (load-file private-file)))))
   #+END_SRC

* Garbage collector tweaks
** Init-time

  #+BEGIN_SRC emacs-lisp
    (setq gc-cons-threshold most-positive-fixnum)
    (add-hook 'after-init-hook (lambda () (setq gc-cons-threshold 800000)))
  #+END_SRC

** Minibuffer

  #+BEGIN_SRC emacs-lisp
    (add-hook 'minibuffer-setup-hook (lambda () (setq gc-cons-threshold most-positive-fixnum)))
    (add-hook 'minibuffer-exit-hook (lambda () (setq gc-cons-threshold 800000)))
  #+END_SRC

* straight.el
** Cache SSL lookups

   #+BEGIN_SRC emacs-lisp
     (customize-set-variable 'nsm-settings-file (concat user-emacs-directory "network-security.data"))
   #+END_SRC

** Bootstrap straight.el

   #+BEGIN_SRC emacs-lisp
     (setq straight-repository-branch "develop")

     (defvar bootstrap-version)
     (let ((bootstrap-file
            (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
           (bootstrap-version 5))
       (unless (file-exists-p bootstrap-file)
         (with-current-buffer
             (url-retrieve-synchronously
              "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
              'silent 'inhibit-cookies)
           (goto-char (point-max))
           (eval-print-last-sexp)))
       (load bootstrap-file nil 'nomessage))

     (straight-use-package 'use-package)
   #+END_SRC

* Disable nswin keybindings
  I don't really want all the default super bindings (I'd prefer a simpler emacs experience).

   #+BEGIN_SRC emacs-lisp

     (let ((unbind-keys '(
			  [?\s-,]
			  [?\s-']
			  [?\s-`]
			  [?\s-~]
			  [?\s--]
			  [?\s-:]
			  [?\s-?]
			  [?\s-^]
			  [?\s-&]
			  [?\s-C]
			  [?\s-D]
			  [?\s-E]
			  [?\s-L]
			  [?\s-M]
			  [?\s-S]
			  [?\s-a]
			  ;;			  [?\s-c]
			  [?\s-d]
			  [?\s-e]
			  [?\s-f]
			  [?\s-g]
			  [?\s-h]
			  [?\s-H]
			  [?\M-\s-h]
			  [?\s-j]
			  [?\s-k]
			  [?\s-l]
			  [?\s-m]
			  [?\s-n]
			  [?\s-o]
			  [?\s-p]
			  [?\s-q]
			  [?\s-s]
			  [?\s-t]
			  [?\s-u]
			  ;;			  [?\s-v]
			  [?\s-w]
			  [?\s-x]
			  [?\s-y]
			  [?\s-z]
			  [?\s-|]
			  [s-kp-bar]
			  [s-right]
			  [s-left]
			  [home]
			  [end]
			  [kp-home]
			  [kp-end]
			  [kp-prior]
			  [kp-next]
			  [S-mouse-1]
			  )))
       (seq-map (lambda (key) (global-unset-key key)) unbind-keys))

   #+END_SRC

* Niceities
** File I/O

   #+BEGIN_SRC emacs-lisp
     (set-language-environment "UTF-8")
     (set-default-coding-systems 'utf-8)

     (setq load-prefer-newer t
	   save-place-file (concat user-emacs-directory "places")
	   backup-directory-alist `(("." . ,(concat user-emacs-directory "backups")))
					     ; auto-revert-interval 1            ; Refresh buffers fast
					     ; recentf-max-saved-items 100       ; Show more recent files
	   sentence-end-double-space nil       ; No double space
	   vc-follow-symlinks nil)
   #+END_SRC

** Disable custom

   #+BEGIN_SRC emacs-lisp
     (setq custom-file (make-temp-file ""))   ; Discard customization's
   #+END_SRC

** Load environment variables

   #+BEGIN_SRC emacs-lisp
     (use-package exec-path-from-shell
       :straight t
       :config
       (when (memq window-system '(mac ns x))
	 (exec-path-from-shell-initialize)))
   #+END_SRC
** Elisp helpers
   #+BEGIN_SRC emacs-lisp
     ;; functional helpers
     (use-package dash
       :straight t)

     ;; string manipulation
     (use-package s
       :straight t)

     ;; filepath manipulation
     (use-package f
       :straight t)
   #+END_SRC

* UI Appearance
** UI Interaction

   #+BEGIN_SRC emacs-lisp
     (fset 'yes-or-no-p 'y-or-n-p)
     (setq apropos-do-all t
	   echo-keystrokes 0.1               ; Show keystrokes asap
	   inhibit-startup-message t         ; No splash screen please
	   initial-scratch-message nil)      ; Clean scratch buffer
   #+END_SRC

** Bell

   #+BEGIN_SRC emacs-lisp
     (setq visible-bell t
	   ring-bell-function
	   (lambda ()
	     (let ((orig-fg (face-foreground 'mode-line)))
	       (set-face-foreground 'mode-line "#F2804F")
	       (run-with-idle-timer 0.1 nil
				    (lambda (fg) (set-face-foreground 'mode-line fg))
				    orig-fg)))
	   inhibit-startup-echo-area-message t)
   #+END_SRC

** Cursor

   #+BEGIN_SRC emacs-lisp
     (setq cursor-type 'hbar)
     (blink-cursor-mode 0)
   #+END_SRC
** Highlight line
   #+BEGIN_SRC emacs-lisp
     (global-hl-line-mode +1)
   #+END_SRC
** Minimal UI

   #+BEGIN_SRC emacs-lisp
     (if (boundp 'toggle-frame-fullscreen) (toggle-frame-fullscreen))
     (if (boundp 'scroll-bar-mode) (scroll-bar-mode 0))
     (if (boundp 'tool-bar-mode) (tool-bar-mode 0))
     (if (boundp 'menu-bar-mode) (menu-bar-mode 0))
   #+END_SRC

** Modeline
   #+BEGIN_SRC emacs-lisp
     (column-number-mode 1)

     ;; Set positon to 'line:column'
     (setq mode-line-position '((line-number-mode ("%l" (column-number-mode ":%c")))))


     (defun simple-mode-line-render (left right)
       "Return a string of `window-width' length containing LEFT aligned respectively."
       (let* ((available-width (- (window-width) (length left) (length right) 2)))
	 (format (format "%%%ds " available-width) " ")))

     (defvar mode-line-center-space
       '(:propertize
	 (:eval (simple-mode-line-render (format-mode-line mode-line-left) (format-mode-line mode-line-right)))
	 face mode-line)
       "Builds center spacing.")
     (put 'mode-line-center-space 'risky-local-variable t)

     (setq mode-line-left
	   '("%e"
	     mode-line-front-space
	     mode-line-client
	     mode-line-modified
	     " "
	     mode-line-position
	     " "
	     mode-line-buffer-identification))

     (setq mode-line-right
	   '(
	     (flycheck-mode flycheck-mode-line)
	     " "
	     mode-name
	     mode-line-process
	     mode-line-misc-info
	     mode-line-end-spaces))

     (setq-default mode-line-format
		   (append mode-line-left '(mode-line-center-space) mode-line-right))
   #+END_SRC

** Line numbering
   #+BEGIN_SRC emacs-lisp
     (use-package nlinum
       :straight t
       :commands global-nlinum-mode
       :config
       (global-nlinum-mode))
   #+END_SRC
** Matching parens highlight
   #+BEGIN_SRC emacs-lisp
     (show-paren-mode)
   #+END_SRC

** Light / Dark theme toggle
   I'd like to toggle between light & dark themes.

*** Dark: Gruvbox-dark-hard
   #+BEGIN_SRC emacs-lisp
     (use-package gruvbox-theme
       :straight t
       :config
       (load-theme 'gruvbox-dark-hard t))

     (defvar dark-theme 'gruvbox-dark-hard)
   #+END_SRC

*** Light: Gruvbox-light-hard
   #+BEGIN_SRC emacs-lisp
     (use-package gruvbox-theme
       :straight t)

     (defvar light-theme 'gruvbox-light-hard)
   #+END_SRC

*** Toggle
    Default to dark theme, but make it easy to switch.

   #+BEGIN_SRC emacs-lisp
     (defvar dark-mode t)

     (defun toggle-theme ()
       (interactive)
       (progn
	 (disable-theme (if dark-mode dark-theme light-theme))
	 (load-theme (if dark-mode light-theme dark-theme) t)
	 (setq dark-mode (not dark-mode))
	 (adapt-theme-org-colors)
	 ))
   #+END_SRC

** Fixed-width font
   #+BEGIN_SRC emacs-lisp
     (set-face-attribute 'default nil
			 :family "IBM Plex Mono"
			 :height 110
			 :weight 'normal
			 :width 'normal)
   #+END_SRC

** Set titlebar color

   #+BEGIN_SRC emacs-lisp
     (when (eq system-type 'darwin)
       (use-package ns-auto-titlebar
	 :straight t
	 :config
	 (ns-auto-titlebar-mode)))
   #+END_SRC

* UI Interaction
** Helm
   #+BEGIN_SRC emacs-lisp
     (use-package helm
       :straight t
       :demand t
       :bind (([remap execute-extended-command] . 'helm-M-x) ;; M-x
	      ([remap switch-to-buffer] . 'helm-mini) ;; C-x b
	      ([remap bookmark-jump] . 'helm-filtered-bookmarks) ;; C-x r b
	      ([remap find-file] . 'helm-find-files) ;; C-x C-f
	      ("s-r" . 'helm-occur)
	      ("s-e" . 'helm-all-mark-rings)
	      ("s-p" . 'helm-etags-select)
	      ("s-t" . 'helm-buffers-list)
	      ("s-;" . 'helm-calcul-expression)
	      ([remap yank-pop] . 'helm-show-kill-ring)) ;; M-y
       :config (progn (helm-mode 1)
		      (helm-autoresize-mode t)
		      (setq helm-M-x-fuzzy-match                  t
			    helm-bookmark-show-location           t
			    helm-buffers-fuzzy-matching           t
			    helm-completion-in-region-fuzzy-match t
			    helm-file-cache-fuzzy-match           t
			    helm-imenu-fuzzy-match                t
			    helm-mode-fuzzy-match                 t
			    helm-locate-fuzzy-match               t
			    helm-quick-update                     t
			    helm-recentf-fuzzy-match              t
			    helm-semantic-fuzzy-match             t
			    helm-etags-fuzzy-match                t
			    helm-etags-match-part-only            'all
			    helm-split-window-inside-p t)))

     (use-package helm-xref
       :straight t
       :config
       (setq xref-show-xrefs-function 'helm-xref-show-xrefs))

     (use-package helm-descbinds
       :straight t
       :config (helm-descbinds-mode))
   #+END_SRC

** Aggressive Indent

   #+BEGIN_SRC emacs-lisp
     (use-package aggressive-indent
       :straight t
       :config
       (global-aggressive-indent-mode 1))
   #+END_SRC

** Company
   #+BEGIN_SRC emacs-lisp
     (use-package company
       :straight t
       :init (setq
	      company-idle-delay 0.1
	      company-minimum-prefix-length 3)
       :config
       (global-company-mode)
       (add-to-list 'company-backends 'company-dabbrev)
       (add-to-list 'company-backends 'company-etags)
       (add-to-list 'company-frontends 'company-tng-frontend)
       (setq company-dabbrev-downcase nil))

     (use-package company-quickhelp
       :straight t
       :init (setq company-quickhelp-delay 0.1)
       :config (company-quickhelp-mode))
   #+END_SRC

** Default to regexp search
   #+BEGIN_SRC emacs-lisp
     (global-set-key [remap isearch-forward] 'isearch-forward-regexp) ;; C-s
   #+END_SRC
** Sublime-like
*** Automatically add newlines at EOF
   #+BEGIN_SRC emacs-lisp
     (setq require-final-newline t)
   #+END_SRC
*** Disable tab indentation

   #+BEGIN_SRC emacs-lisp
     (setq-default indent-tabs-mode nil)
   #+END_SRC

*** Remove trailing whitespace
   #+BEGIN_SRC emacs-lisp
     (add-hook 'before-save-hook 'delete-trailing-whitespace)
   #+END_SRC
*** Expand region
   #+BEGIN_SRC emacs-lisp
     (use-package expand-region
       :straight t
       :bind (("s-f" . 'er/expand-region)
	      ("s-F" . 'er/contract-region)))
   #+END_SRC
*** Multiple cursors
   #+BEGIN_SRC emacs-lisp
     (use-package multiple-cursors
       :straight t
       :config
       (defun select-symbol (arg)
	 "Sets the region to the symbol under the point"
	 (interactive "p")
	 (if mark-active (mc/mark-next-like-this arg) (er/mark-symbol)))
       (defun mark-all-like-symbol (arg)
	 (interactive "p")
	 (progn
	   (unless mark-active (er/mark-symbol))
	   (mc/mark-all-like-this)))
       (add-to-list 'mc/unsupported-minor-modes 'company-mode)
       (add-to-list 'mc/unsupported-minor-modes 'company-quickhelp-mode)
       (add-to-list 'mc/unsupported-minor-modes 'eldoc-mode)
       (add-to-list 'mc/unsupported-minor-modes 'flycheck-mode)
       (add-to-list 'mc/unsupported-minor-modes 'helm-mode)
       (add-to-list 'mc/unsupported-minor-modes 'lsp-ui-doc-mode)
       (add-to-list 'mc/unsupported-minor-modes 'lsp-ui-sideline-mode)
       (add-to-list 'mc/unsupported-minor-modes 'lsp-ui-mode)
       :bind (("s-L" . 'mc/edit-lines)
	      ("s-d" . 'select-symbol)
	      ("s-D" . 'mark-all-like-symbol)
	      ("s-<mouse-1>" . 'mc/add-cursor-on-click)))
   #+END_SRC
*** Comment line / region
   #+BEGIN_SRC emacs-lisp
     (defun comment-line-or-region (beg end)
       "Comment a region or the current line."
       (interactive "*r")
       (save-excursion
	 (if (region-active-p)
	     (comment-or-uncomment-region beg end)
	   (comment-line 1))))

     (global-set-key (kbd "C-\\") 'comment-line-or-region)
     (global-set-key (kbd "s-/") 'comment-line-or-region)
   #+END_SRC
*** Select whole buffer
   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "s-a") 'mark-whole-buffer)
   #+END_SRC
*** Compilation mode tweaks
   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "s-B") 'compile)
     (global-set-key (kbd "s-b") 'recompile)

     (setq compilation-scroll-output 'first-error)
     (use-package ansi-color
       :config
       (defun colorize-compilation-buffer ()
	 (read-only-mode)
	 (ansi-color-apply-on-region compilation-filter-start (point))
	 (read-only-mode))
       :hook ('compilation-filter . #'colorize-compilation-buffer))
   #+END_SRC

*** Indent / Dedent
   #+BEGIN_SRC emacs-lisp
     (defun dedent (start end)
       (interactive "*r")
       (indent-rigidly start end (- tab-width)))

     (defun indent (start end)
       (interactive "*r")
       (indent-rigidly start end tab-width))

     (global-set-key (kbd "s-[") 'dedent)
     (global-set-key (kbd "s-]") 'indent)
   #+END_SRC
*** Guess indentation settings
   #+BEGIN_SRC emacs-lisp
     (use-package dtrt-indent
       :straight t
       :config
       (dtrt-indent-mode 1)
       )
   #+END_SRC
*** Window navigation
   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "M-j") 'previous-multiframe-window)
     (global-set-key (kbd "M-k") 'other-window)

     (use-package ace-window
       :straight t
       :demand t
       :config
       (defun switch-to-nth-window (window-num)
	 (let ((window (nth window-num (aw-window-list))))
	   (when window (select-window window))))
       :bind (
	      ("s-1" . (lambda () (interactive) (switch-to-nth-window 0)))
	      ("s-2" . (lambda () (interactive) (switch-to-nth-window 1)))
	      ("s-3" . (lambda () (interactive) (switch-to-nth-window 2)))
	      ("s-4" . (lambda () (interactive) (switch-to-nth-window 3)))
	      ("s-5" . (lambda () (interactive) (switch-to-nth-window 4)))
	      ("s-6" . (lambda () (interactive) (switch-to-nth-window 5)))
	      ("s-7" . (lambda () (interactive) (switch-to-nth-window 6)))
	      ("s-8" . (lambda () (interactive) (switch-to-nth-window 7)))
	      ("s-9" . (lambda () (interactive) (switch-to-nth-window 8)))
	      ("s-0" . (lambda () (interactive) (switch-to-nth-window 9)))))
   #+END_SRC
*** Go to line
   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "s-l") 'goto-line)
   #+END_SRC

*** Upcase / downcase
   #+BEGIN_SRC emacs-lisp
     (put 'upcase-region 'disabled nil)
     (put 'downcase-region 'disabled nil)
     ;; (global-set-key (kbd "s-k s-u") 'upcase-region)
     ;; (global-set-key (kbd "s-k s-l") 'downcase-region)
   #+END_SRC
*** Electric pair
   #+BEGIN_SRC emacs-lisp
     (electric-pair-mode 1)
   #+END_SRC
*** Auto revert
   #+BEGIN_SRC emacs-lisp
     (global-auto-revert-mode t)
   #+END_SRC
*** s-w is kill-buffer

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "s-w") 'kill-this-buffer)
   #+END_SRC

** CTags
Auto-revert to new tags file
   #+BEGIN_SRC emacs-lisp
     (setq tags-revert-without-query 1)
   #+END_SRC
** Map Super-* to C-c * + smartrep

   #+BEGIN_SRC emacs-lisp
     (defun is-super-binding-p (key)
       (let ((super (elt (event-modifiers (elt (kbd "s-t") 0)) 0))
	     (click (elt (event-modifiers (elt (kbd "<mouse-1>") 0)) 0)))
	 (and (eq (length key) 1)
	      (seq-contains (event-modifiers (elt key 0)) super)
	      (not (seq-contains (event-modifiers (elt key 0)) click)))))

     (defun binding-without-super (key)
       (let ((super (elt (event-modifiers (elt (kbd "s-t") 0)) 0))
	     (first-key (elt key 0)))
	 (event-convert-list
	  (append
	   (seq-remove
	    (lambda (el) (eq el super))
	    (event-modifiers first-key))
	   (list (event-basic-type first-key))))))

     (defun inverse-kbd (key)
       (key-description (list key)))

     (defun gather-bindings (keymap prefix)
       (let ((bindings '()))
	 (map-keymap
	  (lambda (evt val)
	    (if (and
		 val                              ;; this binding has to have a target (eg it wasn't unset)
		 (is-super-binding-p (list evt))) ;; it needs to include the super key
		(let ((new-binding (binding-without-super (list evt))))
		  (if (not (global-key-binding (kbd (concat prefix " " (inverse-kbd (list new-binding))))))
		      (setq bindings (cons (cons (inverse-kbd new-binding) val) bindings))))))
	  keymap)
	 bindings))

     (use-package smartrep
       :straight t)

     (add-hook
      'after-init-hook
      (lambda ()
	(smartrep-define-key
	    global-map "C-c"
	  (gather-bindings global-map "C-c"))))
   #+END_SRC

** Ansi-term improvements
   From https://echosa.github.io/blog/2012/06/06/improving-ansi-term/

*** Close terminal windows when shell exits

   #+BEGIN_SRC emacs-lisp
     (defadvice term-sentinel (around my-advice-term-sentinel (proc msg))
       (if (memq (process-status proc) '(signal exit))
	   (let ((buffer (process-buffer proc)))
	     ad-do-it
	     (kill-buffer buffer))
	 ad-do-it))
     (ad-activate 'term-sentinel)
   #+END_SRC

*** Default to /bin/bash

   #+BEGIN_SRC emacs-lisp
     (setq shell-command-switch "-lc")
     (defvar my-term-shell "/bin/bash")
     (defadvice ansi-term (before force-bash)
       (interactive (list my-term-shell)))
     (ad-activate 'ansi-term)
   #+END_SRC

*** Use utf8

   #+BEGIN_SRC emacs-lisp
     (defun my-term-use-utf8 ()
       (set-buffer-process-coding-system 'utf-8-unix 'utf-8-unix))
     (add-hook 'term-exec-hook 'my-term-use-utf8)
   #+END_SRC

*** Make URLs clickable

   #+BEGIN_SRC emacs-lisp
     (add-hook 'term-mode-hook (lambda () (goto-address-mode)))
   #+END_SRC

*** Handle C-y

   #+BEGIN_SRC emacs-lisp
     (defun my-term-paste (&optional string)
       (interactive)
       (process-send-string
	(get-buffer-process (current-buffer))
	(if string string (current-kill 0))))

     (add-hook 'term-mode-hook (lambda () (define-key term-raw-map "\C-y" 'my-term-paste)))
   #+END_SRC

*** Switch to terminal

   #+BEGIN_SRC emacs-lisp
     (defun nuance-toggle-term ()
       (interactive)
       (if (get-buffer "*ansi-term*")
           (pop-to-buffer "*ansi-term*" 'display-buffer-reuse-window)
         (ansi-term "/bin/bash")))

     (global-set-key (kbd "s-T") 'nuance-toggle-term)
   #+END_SRC

* Packages
** Magit
   #+BEGIN_SRC emacs-lisp
     (if (gethash :magit package-overrides t)
	 (use-package magit
	   :straight t
	   :commands magit-status magit-blame-addition
	   :config
	   (setq magit-branch-arguments nil
		 ;; don't put "origin-" in front of new branch names by default
		 magit-default-tracking-name-function 'magit-default-tracking-name-branch-only
		 magit-push-always-verify nil
		 ;; Get rid of the previous advice to go into fullscreen
		 magit-restore-window-configuration t)
	   :bind ("C-x g" . magit-status)))
   #+END_SRC

** Diff Highlight
   #+BEGIN_SRC emacs-lisp
     (use-package diff-hl
       :straight t
       :config
       (global-diff-hl-mode)
       (diff-hl-margin-mode))
   #+END_SRC

** Flycheck
   #+BEGIN_SRC emacs-lisp
     (use-package flymake
       :straight t
       :bind (("M-n" . flymake-goto-next-error)
	      ("M-p" . flymake-goto-prev-error)))

     (use-package flycheck
       :straight t
       :hook ('prog-mode . #'global-flycheck-mode))

     (use-package flymake-diagnostic-at-point
       :straight t
       :hook ('flymake-mode-hook . #'flymake-diagnostic-at-point-mode)
       :config (setq
		flymake-diagnostic-at-point-error-prefix ""
		flymake-diagnostic-at-point-display-diagnostic-function 'flymake-diagnostic-at-point-display-minibuffer))
   #+END_SRC
** Snippets

   #+BEGIN_SRC emacs-lisp
     (use-package yasnippet :straight t :config (yas-global-mode))
   #+END_SRC


** LSP
   I'm trying out an alternate to lsp-mode, so this is currently disabled

   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package lsp-mode
       :straight t
       :config
       (setq
	lsp-ui-sideline-show-code-actions nil
	lsp-ui-sideline-show-hover nil
	))
     (use-package company-lsp
       :straight t
       :config (add-to-list 'company-backends 'company-lsp))
     (use-package lsp-ui
       :straight t
       :init (add-hook 'lsp-mode-hook 'lsp-ui-mode))
     (use-package lsp-ui-flycheck
       :init (add-hook 'lsp-after-open-hook (lambda () (lsp-ui-flycheck-enable 1))))
   #+END_SRC

   Instead, I'm trying to use eglot

   #+BEGIN_SRC emacs-lisp
     (use-package eglot
       :straight t
       :config
       (setq-default
        eglot-workspace-configuration '((:gopls . (:usePlaceholders t))))
       :hook ((python-mode c++-mode c-mode go-mode rust-mode) . 'eglot-ensure))
   #+END_SRC

** Bug hunter
   Bugs crop up in this file, so pull in some code to help bisect them.

   #+BEGIN_SRC emacs-lisp
     (use-package bug-hunter :straight t)
   #+END_SRC

   Use this by invoking `M-x bug-hunter-init-file` and following instructions.

** Projectile

   Use projectile to index git repos.

   #+BEGIN_SRC emacs-lisp
     (use-package projectile
       :straight t
       :config
       (projectile-mode))

     (use-package helm-projectile
       :straight t
       :init (use-package helm-rg :straight t)
       :bind (([remap helm-etags-select] . 'helm-projectile-find-file-dwim))
       (("s-F" . 'helm-projectile-rg)))
   #+END_SRC

** Org
*** Installation
   #+BEGIN_SRC emacs-lisp
     (use-package org
       :straight org-plus-contrib
       :init
       ;; From https://github.com/raxod502/radian/blob/ee92ea6cb0473bf7d20c6d381753011312ef4a52/radian-emacs/radian-org.el#L46-L112

       ;; This section is devoted to fixing the asinine version-check
       ;; handling in Org (it's not designed to handle the case where you
       ;; run straight from the Git repo, apparently). This is one of the
       ;; worse hacks I've ever had the misfortune to create in Emacs.

       ;; First we define a function to return a proper version string
       ;; based on the Git repo. (This is somewhat similar to what happens
       ;; in org-fixup.el.) We should really define a function that will
       ;; return the latest tag, as well, but this remains a FIXME for now.
       (defun radian--org-git-version ()
	 "Return the abbreviated SHA for the Org Git repo."
	 (let ((default-directory (concat user-emacs-directory
					  "straight/repos/org/")))
	   (if (executable-find "git")
	       (with-temp-buffer
		 ;; Returns the shortest prefix of the SHA for HEAD that is
		 ;; unique, down to a minimum of 4 characters (see
		 ;; git-rev-parse(1)).
		 (call-process "git" nil '(t nil) nil
			       "rev-parse" "--short" "HEAD")
		 (if (> (buffer-size) 0)
		     (string-trim (buffer-string))
		   ;; This shouldn't happen, unless somehow Org is not
		   ;; actually a Git repo.
		   "revision unknown"))
	     ;; This also shouldn't happen, because how would you have
	     ;; gotten Org in the first place, then? But the real world
	     ;; sucks and we have to account for stuff like this.
	     "git not available")))

       ;; Here we're defining `org-git-version' and `org-release' eagerly.
       ;; Pay close attention here, since we actually do this multiple
       ;; times. The control flow is really weird. The reason we define the
       ;; functions here is that Emacs includes its own copy of Org, and
       ;; these functions are autoloaded by Emacs. Now, normally the
       ;; built-in autoloads are overridden by the version of Org
       ;; downloaded from EmacsMirror, but since we're running straight
       ;; from the Git repo, `org-git-version' and `org-release' are not
       ;; generated and autoloaded. So in order to avoid the original
       ;; autoloads from being triggered under any circumstances, we have
       ;; to overwrite them here.
       (defalias #'org-git-version #'radian--org-git-version)
       (defun org-release () "N/A") ; FIXME: replace with a real function

       ;; Now, the culprit function is `org-check-version', which is
       ;; defined in org-compat.el and called from org.el. The problem with
       ;; this function is that if the version of Org in use is not a
       ;; release version (i.e. it's running straight from the repo, as we
       ;; are doing), then it prints a warning. We don't want this. The
       ;; natural thought is to override `org-check-version'.
       ;; Unfortunately, this is completely impossible since
       ;; `org-check-version' is a macro, and org.el (which is where the
       ;; macro is used) is byte-compiled, so the code of
       ;; `org-check-version' is hardcoded into org.elc. The easiest way
       ;; around the problem, other than doing something even more
       ;; horrifying like suppressing warnings while loading Org, seems to
       ;; be to *pretend* that org-version.el is available, even though it
       ;; doesn't exist. Then `org-check-version' happily defines
       ;; `org-git-version' and `org-release' as autoloads pointing to
       ;; org-version.el. Of course, then after Org is loaded, we have to
       ;; override those autoloads to make the functions point back to what
       ;; we want. Right now, the definition of `org-release' generated by
       ;; `org-check-version' is the same as the one used above, so we
       ;; don't bother to change it. That should change, FIXME.
       (provide 'org-version)
       (with-eval-after-load 'org
	 (defalias #'org-git-version #'radian--org-git-version))
       :config
       (require 'ol-notmuch)
       :bind (
	      ("C-c c" . org-capture)
	      ("C-c l" . org-store-link)
	      :map org-mode-map
	      ("C-c g" . org-mac-safari-insert-frontmost-url)
	      ))

     (use-package helm-org
       :straight t
       :config
       (setq helm-org-ignore-autosaves t
	     helm-org-headings-fontify t
	     helm-org-format-outline-path t
	     helm-org-show-filename t
	     helm-org-headings-max-depth 6)
       :bind (:map org-mode-map
		   ("s-r" . helm-org-agenda-files-headings)))
   #+END_SRC
*** Agenda

   #+BEGIN_SRC emacs-lisp
     (setq
      org-agenda-files '("~/org" "~/.emacs.d/init.org" "~/.emacs.d/private.org" "~/.notes")
      org-log-done t
      org-enforce-todo-dependencies t
      ;; refile-related configs from https://blog.aaronbieber.com/2017/03/19/organizing-notes-with-refile.html
      org-refile-targets '((org-agenda-files :maxlevel . 3))
      org-refile-use-outline-path 'file
      org-outline-path-complete-in-steps nil
      org-refile-allow-creating-parent-nodes 'confirm
      org-startup-folded t
      org-agenda-log-mode-items '(closed clock state)
      org-src-tab-acts-natively t
      org-agenda-include-diary t)
     ;; custom todo tags
     (setq org-todo-keywords
	   '((sequence "TODO(t!)" "IN-PROGRESS(i@/!)" "|" "DONE(d!)" "CANCELED(c@!)")
	     (sequence "MEET(m@)" "|" "DONE(d!)")
	     (sequence "IDEA(a!)" "|" "DONE(d!)")))
     (setq org-agenda-custom-commands
	     '(("f" "Today"
		((agenda "" ((org-agenda-span 1)))
		 (tags ":today:" ((org-agenda-overriding-header "Today"))))
		((org-agenda-compact-blocks t)))
	       ("d" "Daily agenda and all TODOs"
	      ((todo "IN-PROGRESS"
		     ((org-agenda-overriding-header "Unfinished tasks:")))
	       (agenda "" ((org-agenda-span 1)))
	       (tags ":refile:"
		     ((org-agenda-overriding-header "To refile:")))
	       (todo "TODO"
		     ((org-agenda-overriding-header "Open tasks:")))
	       (todo "MEET"
		     ((org-agenda-overriding-header "People to meet:")
		      (org-agenda-max-entries 5)))
	       (todo "IDEA"
		     ((org-agenda-overriding-header "Ideas:")
		      (org-agenda-max-entries 5))))
	      ((org-agenda-compact-blocks t)))
	     ("p" "3-week context plan"
	      ((agenda "" ((org-agenda-start-day "-7d") (org-agenda-span 21))))
	      ((org-agenda-compact-blocks t)
	       (org-agenda-include-inactive-timestamps 't)))
	     ("h" "last half dates"
	      ((agenda "" ((org-agenda-start-day "-6m") (org-agenda-span 183))))
	      ((org-agenda-compact-blocks t)
	       (org-agenda-include-inactive-timestamps 't)))))
   #+END_SRC

*** Prettier org mode
Adapted from https://zzamboni.org/post/beautifying-org-mode-in-emacs/

   #+BEGIN_SRC emacs-lisp
     (defun adapt-theme-org-colors ()
       (let* ((variable-tuple
	       (cond ((x-list-fonts "IBM Plex Sans") '(:font "IBM Plex Sans"))
		     ((x-list-fonts "SF Pro Text") '(:font "SF Pro Text"))
		     ((x-family-fonts "Sans Serif")    '(:family "Sans Serif"))
		     (nil (warn "Cannot find a Sans Serif Font."))))
	      (base-font-color     (face-foreground 'default nil 'default))
	      (headline           `(:inherit default :weight bold :foreground ,base-font-color)))

	 (custom-theme-set-faces
	  'user
	  `(org-level-8 ((t (,@headline ,@variable-tuple))))
	  `(org-level-7 ((t (,@headline ,@variable-tuple))))
	  `(org-level-6 ((t (,@headline ,@variable-tuple))))
	  `(org-level-5 ((t (,@headline ,@variable-tuple))))
	  `(org-level-4 ((t (,@headline ,@variable-tuple :height 1.1))))
	  `(org-level-3 ((t (,@headline ,@variable-tuple :height 1.2))))
	  `(org-level-2 ((t (,@headline ,@variable-tuple :height 1.3))))
	  `(org-level-1 ((t (,@headline ,@variable-tuple :height 1.4))))
	  `(org-document-title ((t (,@headline ,@variable-tuple :height 1.5 :underline nil))))))

       (custom-theme-set-faces
	'user
	'(variable-pitch ((t (:family "IBM Plex Sans" :height 120 :weight light))))
	'(fixed-pitch ((t ( :family "IBM Plex Mono" :slant normal :weight normal :height 110 :width normal)))))
       (add-hook 'org-mode-hook 'variable-pitch-mode)
       (add-hook 'org-mode-hook 'visual-line-mode)
       (custom-theme-set-faces
	'user
	'(org-block                 ((t (:inherit fixed-pitch))))
	'(org-document-info         ((t (:foreground "dark orange"))))
	'(org-document-info-keyword ((t (:inherit (shadow fixed-pitch)))))
	'(org-link                  ((t (:foreground "royal blue" :underline t))))
	'(org-meta-line             ((t (:inherit (font-lock-comment-face fixed-pitch)))))
	'(org-property-value        ((t (:inherit fixed-pitch))) t)
	'(org-special-keyword       ((t (:inherit (font-lock-comment-face fixed-pitch)))))
	'(org-tag                   ((t (:inherit (shadow fixed-pitch) :weight bold :height 0.8))))
	'(org-verbatim              ((t (:inherit (shadow fixed-pitch)))))
	'(org-indent                ((t (:inherit (org-hide fixed-pitch)))))))
     (when window-system
       (progn
	 (setq org-hide-emphasis-markers t)
	 (font-lock-add-keywords 'org-mode
				 '(("^ *\\([-]\\) "
				    (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
	 (use-package org-bullets
	   :straight t
	   :config
	   (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
	 (adapt-theme-org-colors)
	 ))
   #+END_SRC

*** Window interaction
    Don't mess up the window layout when editing code blocks.

   #+BEGIN_SRC emacs-lisp
     (setq org-src-window-setup 'current-window)
   #+END_SRC
** Jupyter
   Support for working with jupyter notebooks, mostlfy focused on interaction with org / org-babel.

   #+BEGIN_SRC emacs-lisp
     (use-package jupyter
       :straight t
       :config
       (org-babel-do-load-languages
        'org-babel-load-languages
        '((latex . t)
          (python . t)
          (emacs-lisp . t)
          (jupyter . t)))
       (setq org-babel-default-header-args:jupyter-python '((:async . "yes")
                                                            (:session . "py")
                                                            (:kernel . "python3")))
       (org-babel-jupyter-override-src-block "python"))
   #+END_SRC

** Tramp

#+BEGIN_SRC emacs-lisp
  (use-package tramp
    :config
    (setq tramp-auto-save-directory "/tmp" tramp-ssh-controlmaster-options ""))
#+END_SRC

* File-type support
** YAML
   #+BEGIN_SRC emacs-lisp
     (use-package yaml-mode
       :straight t
       :mode "\\.yml\\'")
   #+END_SRC

** Thrift
   #+BEGIN_SRC emacs-lisp
     (use-package thrift-mode
       :straight t)
   #+END_SRC

** Protobuf

   #+BEGIN_SRC emacs-lisp
     (use-package protobuf-mode
       :straight t)
   #+END_SRC

** Lua
   #+BEGIN_SRC emacs-lisp
     (use-package lua-mode
       :straight t
       :config
       (flycheck-define-checker lua-luacheck-old
	 "A Lua syntax checker using luacheck.

     See URL `https://github.com/mpeterv/luacheck'."
	 :command ("luacheck"
		   ;; "--formatter" "plain"
		   ;; "--codes"                   ; Show warning codes
		   "--no-color"
		   (option-list "--std" flycheck-luacheck-standards)
		   (config-file "--config" flycheck-luacheckrc)
		   ;; "--filename" source-original
		   ;; Read from standard input
		   source-original)
	 :standard-input t
	 :error-patterns
	 ((warning line-start
		   (optional (minimal-match (one-or-more not-newline)))
		   ":" line ":" column
		   ": (" (id "W" (one-or-more digit)) ") "
		   (message) line-end)
	  (error line-start
		 (optional (minimal-match (one-or-more not-newline)))
		 ":" line ":" column ":"
		 ;; `luacheck' before 0.11.0 did not output codes for errors, hence
		 ;; the ID is optional here
		 (optional " (" (id "E" (one-or-more digit)) ") ")
		 (message) line-end))
	 :modes lua-mode)
       :hook
       (lua-mode
	.
	(lambda()
	  (set (make-local-variable 'compile-command)
	       (let ((file (file-name-nondirectory buffer-file-name)))
		 (format "luacheck --no-color %s" file))))))

   #+END_SRC

** ANTLR
   #+BEGIN_SRC emacs-lisp
     (use-package antlr-mode
       :mode ("\\.g4\\'" . antlr-mode)
       :straight t)
   #+END_SRC
** C++

   CQuery is disabled, but I still want C++ support

   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package cquery
       :straight t
       :if
       (file-exists-p "/bin/cquery")
       :bind
       (:map c-mode-base-map
	     ("C-t h c" . cquery-call-hierarchy)
	     ("C-t h i" . cquery-inheritance-hierarchy)
	     ("C-t i" . lsp-ui-sideline-toggle-symbols-info)
	     ("C-t I". helm-imenu)
	     ("C-t h m" . cquery-member-hierarchy)
	     ("C-t ." . lsp-ui-peek-find-definitions)
	     ("C-t ?" . lsp-ui-peek-find-references))
       :preface
       (defun cquery//enable ()
	 (condition-case nil
	     (lsp)
	   (user-error nil)))
       :init
       (add-hook 'c-mode-common-hook #'cquery//enable)
       (defun cquery-cache-dir (dir)
	 (expand-file-name cquery-cache-dir "/home/mhj/.cquery_cache"))
       (setq cquery-cache-dir-function #'cquery-cache-dir)
       :config
       (setq
	cquery-executable "/bin/cquery"
	cquery-extra-args '("--log-file=/tmp/cq.log")
	cquery-extra-init-params '(:completion (:detailedLabel t))
	cquery-sem-highlight-method 'font-lock
	company-transformers nil
	company-lsp-async t
	company-lsp-cache-candidates nil
	xref-prompt-for-identifier '(not
				     xref-find-definitions
				     xref-find-definitions-other-window
				     xref-find-definitions-other-frame
				     xref-find-references)))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package clang-format
       :straight t
       :config
       (progn
	 (defun clang-format-before-save ()
	   "Add this to .emacs to clang-format on save
      (add-hook 'before-save-hook 'clang-format-before-save)."

	   (interactive)
	   (when (eq major-mode 'c++-mode) (clang-format-buffer))))
       :hook ('before-save . #'clang-format-before-save))

     (use-package cc-mode
       :mode ("\\.h|\\.cpp" . c++-mode))
   #+END_SRC
** Python
   #+BEGIN_SRC emacs-lisp
     (use-package blacken
       :straight t
       :hook (python-mode . blacken-mode))

     (setq
      flycheck-python-pycompile-executable "python3"
      flycheck-python-flake8-executable "flake8")

     (use-package virtualenvwrapper
       :straight t
       :init (setq venv-location (expand-file-name "~/.pyenv/versions"))
       :config (venv-initialize-interactive-shells))
   #+END_SRC

** Cython
   #+BEGIN_SRC emacs-lisp
     (use-package cython-mode
       :straight t)
   #+END_SRC

** Rust

   #+BEGIN_SRC emacs-lisp
     (use-package rust-mode
       :straight t)
   #+END_SRC

** Go

   #+BEGIN_SRC emacs-lisp
     (use-package go-mode
       :straight t
       :config (setq gofmt-command "goimports")
       :hook ('before-save . #'gofmt-before-save))
   #+END_SRC

** Bazel

   #+BEGIN_SRC emacs-lisp
     (use-package bazel-mode
       :straight
       (emacs-bazel-mode
	:host github
	:repo "bazelbuild/emacs-bazel-mode")
       :mode ("'BUILD'" "'WORKSPACE'" "\\.bzl\\'")
       :custom (
		(bazel-mode-buildifier-before-save t)
		(bazel-mode-buildifier-command "~/go/bin/buildifier"))
       )
   #+END_SRC

** Markdown

   #+BEGIN_SRC emacs-lisp
     (use-package markdown-mode
       :straight t
       :commands (markdown-mode gfm-mode)
       :mode (("README\\.md\\'" . gfm-mode)
	      ("\\.md\\'" . markdown-mode)
	      ("\\.markdown\\'" . markdown-mode))
       :init (setq markdown-command "multimarkdown"
		   markdown-header-scaling t
		   markdown-hide-urls t
		   markdown-marginalize-headers nil
		   markdown-marginalize-headers-margin-width 4
		   markdown-fontify-code-blocks-natively t)
       :hook
       (('markdown-mode .'variable-pitch-mode)
       ('markdown-mode . 'visual-line-mode)))
   #+END_SRC

** Terraform
   Trying out terraform for managing AWS stuff.

   #+BEGIN_SRC emacs-lisp
     (use-package terraform-mode
       :straight t
       :hook ('terraform-mode-hook . #'terraform-format-on-save-mode))

     (use-package company-terraform
       :straight t
       :config
       (company-terraform-init))

     (add-to-list 'eglot-server-programs '(terraform-mode . ("tflint" "--langserver")))

     (flycheck-define-checker terraform-validate
       "A Terraform syntax checker with `terraform validate.
	       See URL `https://www.terraform.io/docs/commands/validate.html'."
       :command ("terraform" "validate" "-no-color")
       :standard-input t
       :error-patterns
       ((error line-start "Error: " (one-or-more not-newline)
	       "\n\n  on " (file-name) " line " line ", " (one-or-more not-newline) "\n"
	       (one-or-more not-newline) "\n\n"
	       (message (one-or-more (and (one-or-more (not (any ?\n))) ?\n)))
	       line-end))
       :next-checkers ((warning . terraform-tflint))
       :modes terraform-mode)

     (add-to-list 'flycheck-checkers 'terraform-validate)
   #+END_SRC

** Dockerfile

   #+BEGIN_SRC emacs-lisp
      (use-package dockerfile-mode :straight t)
   #+END_SRC

** Nix

   #+BEGIN_SRC emacs-lisp
     (use-package nix-mode
       :straight t
       :mode ("\\.nix\\'" "\\.nix.in\\'"))

     (use-package nix-drv-mode
       :mode "\\.drv\\'")

     (use-package nix-shell
       :commands (nix-shell-unpack nix-shell-configure nix-shell-build))

     (use-package nix-repl
       :commands (nix-repl))
   #+END_SRC
* Startup
Launch a server if not currently running, default to showing org daily agenda

   #+BEGIN_SRC emacs-lisp
     (setq server-socket-dir "~/.emacs.d/server")
     (server-start)
     (org-agenda nil "d")
     (delete-other-windows)
   #+END_SRC

* License

  My Emacs configurations written in Org mode.

  Copyright (c) 2019 Matthew Jones

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
