#+TITLE: Emacs configuration file
#+AUTHOR: Matthew Jones
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle yes

* In-flight
** DONE Combine mappings between C-c * & S-* (eg "C-c d" & "S-d" should do the same thing)
** TODO Use smartrep or hydra for C-c / S- bindings (eg "C-c ddd" to select current symbol & next two instances)

* About

   My emacs config, heavily inspired / forked from [[https://github.com/larstvei/dot-emacs]].

* Configurations
** Meta

   All changes to the configuration should be done in =init.org=, *not* in
   =init.el=. Any changes in the =init.el= will be overwritten by saving
   =init.org=. The =init.el= in this repo should not be tracked by git, and
   is replaced the first time Emacs is started (assuming it has been renamed
   to =~/.emacs.d=).

   Emacs can't load =.org=-files directly, but =org-mode= provides functions
   to extract the code blocks and write them to a file. There are multiple
   ways of handling this; like suggested by [[http://emacs.stackexchange.com/questions/3143/can-i-use-org-mode-to-structure-my-emacs-or-other-el-configuration-file][this StackOverflow post]], one
   could just use =org-babel-load-file=, but I had problems with
   byte-compilation. Previously I tracked both the =org.=- and =el.=-files,
   but the git commits got a little messy. So here is a new approach.

   When this configuration is loaded for the first time, the ~init.el~ is
   the file that is loaded. It looks like this:

   #+BEGIN_SRC emacs-lisp :tangle no
     ;; This file replaces itself with the actual configuration at first run.

     ;; We can't tangle without org!
     (require 'org)
     ;; Open the configuration
     (find-file (concat user-emacs-directory "init.org"))
     ;; tangle it
     (org-babel-tangle)
     ;; load it
     (load-file (concat user-emacs-directory "init.el"))
     ;; finally byte-compile it
     (byte-compile-file (concat user-emacs-directory "init.el"))
   #+END_SRC

   It tangles the org-file, so that this file is overwritten with the actual
   configuration.

   There is no reason to track the =init.el= that is generated; by running
   the following command =git= will not bother tracking it:

   #+BEGIN_SRC sh :tangle no
     git update-index --assume-unchanged init.el
   #+END_SRC

   If one wishes to make changes to the repo-version of =init.el= start
   tracking again with:

   #+BEGIN_SRC sh :tangle no
     git update-index --no-assume-unchanged init.el
   #+END_SRC

   I want lexical scoping for the init-file, which can be specified in the
   header. The first line of the configuration is as follows:

   #+BEGIN_SRC emacs-lisp :tangle no
     ;;; -*- lexical-binding: t -*-
   #+END_SRC

   The =init.el= should (after the first run) mirror the source blocks in
   the =init.org=. We can use =C-c C-v t= to run =org-babel-tangle=, which
   extracts the code blocks from the current file into a source-specific
   file (in this case a =.el=-file).

   To avoid doing this each time a change is made we can add a function to
   the =after-save-hook= ensuring to always tangle and byte-compile the
   =org=-document after changes.

   #+BEGIN_SRC emacs-lisp
     (defun tangle-init ()
       "If the current buffer is 'init.org' the code-blocks are
     tangled, and the tangled file is compiled."
       (when (equal (buffer-file-name)
		    (expand-file-name (concat user-emacs-directory "init.org")))
	 ;; Avoid running hooks when tangling.
	 (let ((prog-mode-hook nil))
	   (org-babel-tangle)
	   ;; (byte-compile-file (concat user-emacs-directory "init.el"))
	   )))

     (add-hook 'after-save-hook 'tangle-init)
   #+END_SRC

   I sometimes want to exclude packages on certain machines, so load that.

   #+BEGIN_SRC emacs-lisp
     (setq package-overrides (make-hash-table))
     (let ((overrides-file (concat user-emacs-directory "config_overrides.el")))
	    (when (file-exists-p overrides-file)
	      (load-file overrides-file)))
   #+END_SRC


   I'd like to keep a few settings private, so we load a =private.el= if it
   exists after the init-file has loaded.

   #+BEGIN_SRC emacs-lisp
     (add-hook
      'after-init-hook
      (lambda ()
	(let ((private-file (concat user-emacs-directory "private.el")))
	  (when (file-exists-p private-file)
	    (load-file private-file)))))
   #+END_SRC

* Garbage collector tweaks
** Init-time

  #+BEGIN_SRC emacs-lisp
    (setq gc-cons-threshold most-positive-fixnum)
    (add-hook 'after-init-hook (lambda () (setq gc-cons-threshold 800000)))
  #+END_SRC

** Minibuffer

  #+BEGIN_SRC emacs-lisp
    (add-hook 'minibuffer-setup-hook (lambda () (setq gc-cons-threshold most-positive-fixnum)))
    (add-hook 'minibuffer-exit-hook (lambda () (setq gc-cons-threshold 800000)))
  #+END_SRC

* straight.el
** Cache SSL lookups

   #+BEGIN_SRC emacs-lisp
     (customize-set-variable 'nsm-settings-file (concat user-emacs-directory "network-security.data"))
   #+END_SRC

** Bootstrap straight.el

   #+BEGIN_SRC emacs-lisp
     ;; disable the GNU ELPA
     (setq package-archives nil)
     ;; initialize the package system
     (package-initialize)

     (defvar bootstrap-version)
     (let ((bootstrap-file
	    (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
	   (bootstrap-version 5))
       (unless (file-exists-p bootstrap-file)
	 (with-current-buffer
	     (url-retrieve-synchronously
	      "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
	      'silent 'inhibit-cookies)
	   (goto-char (point-max))
	   (eval-print-last-sexp)))
       (load bootstrap-file nil 'nomessage))

     (straight-use-package 'use-package)
   #+END_SRC

* Niceities
** File I/O

   #+BEGIN_SRC emacs-lisp
     (set-language-environment "UTF-8")
     (set-default-coding-systems 'utf-8)

     (setq load-prefer-newer t
	   save-place-file (concat user-emacs-directory "places")
	   backup-directory-alist `(("." . ,(concat user-emacs-directory "backups")))
	   ; auto-revert-interval 1            ; Refresh buffers fast
	   ; recentf-max-saved-items 100       ; Show more recent files
	   sentence-end-double-space nil)    ; No double space
   #+END_SRC

** Disable custom

   #+BEGIN_SRC emacs-lisp
     (setq custom-file (make-temp-file ""))   ; Discard customization's
   #+END_SRC

** Load environment variables

   #+BEGIN_SRC emacs-lisp
     (when window-system
       (let ((path-from-shell (shell-command-to-string "/bin/bash -l -c 'echo $PATH'")))
	 (setenv "PATH" path-from-shell)
	 (setq exec-path (split-string path-from-shell path-separator))))
   #+END_SRC
** Elisp helpers
#+BEGIN_SRC emacs-lisp
  ;; functional helpers
  (use-package dash
    :straight t)

  ;; string manipulation
  (use-package s
    :straight t)

  ;; filepath manipulation
  (use-package f
    :straight t)
#+END_SRC

* UI Appearance
** UI Interaction

   #+BEGIN_SRC emacs-lisp
     (fset 'yes-or-no-p 'y-or-n-p)
     (setq apropos-do-all t
	   echo-keystrokes 0.1               ; Show keystrokes asap
	   inhibit-startup-message t         ; No splash screen please
	   initial-scratch-message nil)      ; Clean scratch buffer
   #+END_SRC

** Bell

   #+BEGIN_SRC emacs-lisp
     (setq visible-bell t
	   ring-bell-function
	   (lambda ()
	     (let ((orig-fg (face-foreground 'mode-line)))
	       (set-face-foreground 'mode-line "#F2804F")
	       (run-with-idle-timer 0.1 nil
				    (lambda (fg) (set-face-foreground 'mode-line fg))
				    orig-fg)))
	   inhibit-startup-echo-area-message t)
   #+END_SRC

** Cursor

   #+BEGIN_SRC emacs-lisp
     (setq cursor-type 'hbar)
     (blink-cursor-mode 0)
   #+END_SRC
** Highlight line
#+BEGIN_SRC emacs-lisp
  (global-hl-line-mode +1)
#+END_SRC
** Minimal UI

   #+BEGIN_SRC emacs-lisp
     (if (boundp 'toggle-frame-fullscreen) (toggle-frame-fullscreen))
     (if (boundp 'scroll-bar-mode) (scroll-bar-mode 0))
     (if (boundp 'tool-bar-mode) (tool-bar-mode 0))
     (if (boundp 'menu-bar-mode) (menu-bar-mode 0))
   #+END_SRC

** Gotham theme
#+BEGIN_SRC emacs-lisp
  (use-package gotham-theme
    :straight t
    :config
    (customize-set-variable 'gotham-tty-256-colors t)
    (load-theme 'gotham t))
#+END_SRC
** Fira Code Retina font
#+BEGIN_SRC emacs-lisp
  (when (window-system)
    (progn
      ;; (set-default-font "Fira Code Retina-11")
      (set-face-attribute 'default nil
			  :family "Fira Code Retina"
			  :height 110
			  :weight 'normal
			  :width 'normal)

      (let ((alist '(
		     (33 . ".\\(?:\\(?:==\\|!!\\)\\|[!=]\\)")
		     (35 . ".\\(?:###\\|##\\|_(\\|[#(?[_{]\\)")
		     (36 . ".\\(?:>\\)")
		     (37 . ".\\(?:\\(?:%%\\)\\|%\\)")
		     (38 . ".\\(?:\\(?:&&\\)\\|&\\)")
		     (42 . ".\\(?:\\(?:\\*\\*/\\)\\|\\(?:\\*[*/]\\)\\|[*/>]\\)")
		     (43 . ".\\(?:\\(?:\\+\\+\\)\\|[+>]\\)")
		     (45 . ".\\(?:\\(?:-[>-]\\|<<\\|>>\\)\\|[<>}~-]\\)")
		     (46 . ".\\(?:\\(?:\\.[.<]\\)\\|[.=-]\\)")
		     (47 . ".\\(?:\\(?:\\*\\*\\|//\\|==\\)\\|[*/=>]\\)")
		     (48 . ".\\(?:x[a-zA-Z]\\)")
		     (58 . ".\\(?:::\\|[:=]\\)")
		     (59 . ".\\(?:;;\\|;\\)")
		     (60 . ".\\(?:\\(?:!--\\)\\|\\(?:~~\\|->\\|\\$>\\|\\*>\\|\\+>\\|--\\|<[<=-]\\|=[<=>]\\||>\\)\\|[*$+~/<=>|-]\\)")
		     ;; (61 . ".\\(?:\\(?:/=\\|:=\\|<<\\|=[=>]\\|>>\\)\\|[<=>~]\\)")
		     (62 . ".\\(?:\\(?:=>\\|>[=>-]\\)\\|[=>-]\\)")
		     (63 . ".\\(?:\\(\\?\\?\\)\\|[:=?]\\)")
		     (91 . ".\\(?:]\\)")
		     (92 . ".\\(?:\\(?:\\\\\\\\\\)\\|\\\\\\)")
		     (94 . ".\\(?:=\\)")
		     (119 . ".\\(?:ww\\)")
		     (123 . ".\\(?:-\\)")
		     (124 . ".\\(?:\\(?:|[=|]\\)\\|[=>|]\\)")
		     (126 . ".\\(?:~>\\|~~\\|[>=@~-]\\)")
		     )
		   ))
	(dolist (char-regexp alist)
	  (set-char-table-range composition-function-table (car char-regexp)
				`([,(cdr char-regexp) 0 font-shape-gstring]))))))
#+END_SRC

** Modeline
#+BEGIN_SRC emacs-lisp
  (column-number-mode 1)

  ;; Set positon to 'line:column'
  (setq mode-line-position '((line-number-mode ("%l" (column-number-mode ":%c")))))


  (defun simple-mode-line-render (left right)
    "Return a string of `window-width' length containing LEFT aligned respectively."
    (let* ((available-width (- (window-width) (length left) (length right) 2)))
      (format (format "%%%ds " available-width) " ")))

  (defvar mode-line-center-space
    '(:propertize
      (:eval (simple-mode-line-render (format-mode-line mode-line-left) (format-mode-line mode-line-right)))
      face mode-line)
    "Builds center spacing.")
  (put 'mode-line-center-space 'risky-local-variable t)

  (setq mode-line-left
	'("%e"
	  mode-line-front-space
	  mode-line-client
	  mode-line-modified
	  " "
	  mode-line-position
	  " "
	  mode-line-buffer-identification))

  (setq mode-line-right
	'(
	  (flycheck-mode flycheck-mode-line)
	  " "
	  mode-name
	  mode-line-process
	  mode-line-misc-info
	  mode-line-end-spaces))

  (setq-default mode-line-format
		(append mode-line-left '(mode-line-center-space) mode-line-right))
#+END_SRC

** Line numbering
#+BEGIN_SRC emacs-lisp
  (use-package nlinum
  :straight t
  :commands global-nlinum-mode
  :config
  (global-nlinum-mode))
#+END_SRC
** Matching parens highlight
#+BEGIN_SRC emacs-lisp
  (show-paren-mode)
#+END_SRC

* UI Interaction
** Helm
#+BEGIN_SRC emacs-lisp
    (use-package helm
      :straight t
      :demand t
      :bind (([remap execute-extended-command] . 'helm-M-x) ;; M-x
	     ([remap switch-to-buffer] . 'helm-mini) ;; C-x b
	     ([remap bookmark-jump] . 'helm-filtered-bookmarks) ;; C-x r b
	     ([remap find-file] . 'helm-find-files) ;; C-x C-f
	     ("s-r" . 'helm-occur)
	     ("s-e" . 'helm-mark-ring)
	     ("s-p" . 'helm-etags-select)
	     ("s-t" . 'helm-buffers-list)
	     ([remap yank-pop] . 'helm-show-kill-ring)) ;; M-y
      :config (progn (helm-mode 1)
		     (helm-autoresize-mode t)
		     (setq helm-M-x-fuzzy-match                  t
			   helm-bookmark-show-location           t
			   helm-buffers-fuzzy-matching           t
			   helm-completion-in-region-fuzzy-match t
			   helm-file-cache-fuzzy-match           t
			   helm-imenu-fuzzy-match                t
			   helm-mode-fuzzy-match                 t
			   helm-locate-fuzzy-match               t
			   helm-quick-update                     t
			   helm-recentf-fuzzy-match              t
			   helm-semantic-fuzzy-match             t
			   helm-etags-fuzzy-match                t
			   helm-etags-match-part-only            'all
			   helm-split-window-inside-p t)))

    (use-package helm-xref
	  :straight t
	  :config
	  (setq xref-show-xrefs-function 'helm-xref-show-xrefs))

    (use-package helm-descbinds
      :straight t
      :config (helm-descbinds-mode))
#+END_SRC

** Aggressive Indent

#+BEGIN_SRC emacs-lisp
  (use-package aggressive-indent
    :straight t
    :config
    (global-aggressive-indent-mode 1))
#+END_SRC

** Company
#+BEGIN_SRC emacs-lisp
  (use-package company
    :straight t
    :init (setq
	   company-idle-delay 0.1
	   company-minimum-prefix-length 3)
    :config
    (global-company-mode)
    (add-to-list 'company-backends 'company-dabbrev)
    (add-to-list 'company-backends 'company-etags)
    (add-to-list 'company-frontends 'company-tng-frontend)
    (setq company-dabbrev-downcase nil))

  (use-package company-quickhelp
    :straight t
    :init (setq company-quickhelp-delay 0.1)
    :config (company-quickhelp-mode))
#+END_SRC

** Default to regexp search
#+BEGIN_SRC emacs-lisp
  (global-set-key [remap isearch-forward] 'isearch-forward-regexp) ;; C-s
#+END_SRC
** Sublime-like
*** Automatically add newlines at EOF
#+BEGIN_SRC emacs-lisp
  (setq require-final-newline t)
#+END_SRC
*** Remove trailing whitespace
#+BEGIN_SRC emacs-lisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC
*** Expand region
#+BEGIN_SRC emacs-lisp
    (use-package expand-region
      :straight t
      :bind (("s-f" . 'er/expand-region)
	     ("s-F" . 'er/contract-region)))
#+END_SRC
*** Multiple cursors
#+BEGIN_SRC emacs-lisp
    (use-package multiple-cursors
      :straight t
      :config
      (defun select-symbol (arg)
	"Sets the region to the symbol under the point"
	(interactive "p")
	(if mark-active (mc/mark-next-like-this arg) (er/mark-symbol)))
      (defun mark-all-like-symbol (arg)
	(interactive "p")
	(progn
	  (unless mark-active (er/mark-symbol))
	  (mc/mark-all-like-this)))
      (add-to-list 'mc/unsupported-minor-modes 'company-mode)
      (add-to-list 'mc/unsupported-minor-modes 'company-quickhelp-mode)
      (add-to-list 'mc/unsupported-minor-modes 'eldoc-mode)
      (add-to-list 'mc/unsupported-minor-modes 'flycheck-mode)
      (add-to-list 'mc/unsupported-minor-modes 'helm-mode)
      (add-to-list 'mc/unsupported-minor-modes 'lsp-ui-doc-mode)
      (add-to-list 'mc/unsupported-minor-modes 'lsp-ui-sideline-mode)
      (add-to-list 'mc/unsupported-minor-modes 'lsp-ui-mode)
      :bind (("s-L" . 'mc/edit-lines)
	     ("s-d" . 'select-symbol)
	     ("s-D" . 'mark-all-like-symbol)
	     ("s-<mouse-1>" . 'mc/add-cursor-on-click)))
#+END_SRC
*** Comment line / region
#+BEGIN_SRC emacs-lisp
  (defun comment-line-or-region (beg end)
    "Comment a region or the current line."
    (interactive "*r")
    (save-excursion
      (if (region-active-p)
	  (comment-or-uncomment-region beg end)
	(comment-line 1))))

  (global-set-key (kbd "C-\\") 'comment-line-or-region)
  (global-set-key (kbd "s-/") 'comment-line-or-region)
#+END_SRC
*** Select whole buffer
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "s-a") 'mark-whole-buffer)
#+END_SRC
*** Compilation mode tweaks
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "s-B") 'compile)
  (global-set-key (kbd "s-b") 'recompile)

  (setq compilation-scroll-output 'first-error)
  (use-package ansi-color
    :config
    (defun colorize-compilation-buffer ()
      (read-only-mode)
      (ansi-color-apply-on-region compilation-filter-start (point))
      (read-only-mode))
    :hook ('compilation-filter . #'colorize-compilation-buffer))
#+END_SRC

*** Indent / Dedent
#+BEGIN_SRC emacs-lisp
  (defun dedent (start end)
    (interactive "*r")
    (indent-rigidly start end (- tab-width)))

  (defun indent (start end)
    (interactive "*r")
    (indent-rigidly start end tab-width))

  (global-set-key (kbd "s-[") 'dedent)
  (global-set-key (kbd "s-]") 'indent)
#+END_SRC
*** Guess indentation settings
#+BEGIN_SRC emacs-lisp
  (use-package dtrt-indent
    :straight t
    :config
    (dtrt-indent-mode 1)
    )
#+END_SRC
*** Window navigation
#+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "M-j") 'previous-multiframe-window)
    (global-set-key (kbd "M-k") 'other-window)

    (use-package ace-window
      :straight t
      :config
      (defun switch-to-nth-window (window-num)
	(let ((window (nth window-num (aw-window-list))))
	  (when window (select-window window))))
      :bind (
	     ("s-1" . (lambda () (interactive) (switch-to-nth-window 0)))
	     ("s-2" . (lambda () (interactive) (switch-to-nth-window 1)))
	     ("s-3" . (lambda () (interactive) (switch-to-nth-window 2)))
	     ("s-4" . (lambda () (interactive) (switch-to-nth-window 3)))
	     ("s-5" . (lambda () (interactive) (switch-to-nth-window 4)))
	     ("s-6" . (lambda () (interactive) (switch-to-nth-window 5)))
	     ("s-7" . (lambda () (interactive) (switch-to-nth-window 6)))
	     ("s-8" . (lambda () (interactive) (switch-to-nth-window 7)))
	     ("s-9" . (lambda () (interactive) (switch-to-nth-window 8)))
	     ("s-0" . (lambda () (interactive) (switch-to-nth-window 9)))
	     ("s-T" . ace-window)))
#+END_SRC
*** Go to line
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "s-l") 'goto-line)
#+END_SRC

*** Upcase / downcase
#+BEGIN_SRC emacs-lisp
  (put 'upcase-region 'disabled nil)
  (put 'downcase-region 'disabled nil)
  ;; (global-set-key (kbd "s-k s-u") 'upcase-region)
  ;; (global-set-key (kbd "s-k s-l") 'downcase-region)
#+END_SRC
*** Electric pair
#+BEGIN_SRC emacs-lisp
  (electric-pair-mode 1)
#+END_SRC
*** Auto revert
#+BEGIN_SRC emacs-lisp
  (global-auto-revert-mode t)
#+END_SRC
** CTags
Auto-revert to new tags file
#+BEGIN_SRC emacs-lisp
  (setq tags-revert-without-query 1)
#+END_SRC
** Calc
#+BEGIN_SRC emacs-lisp
  (defun calc-eval-region (beg end)
    "Eval the arithmetic expression in the region and replace it with the result"
    (interactive "r")
    (let ((val (calc-eval (buffer-substring beg end))))
      (delete-region beg end)
      (insert val)))

  (global-set-key (kbd "s-;") 'calc-eval-region)
#+END_SRC

** Map Super-* to C-c * + smartrep

   #+BEGIN_SRC emacs-lisp
     (defun is-super-binding-p (key)
       (let ((super (elt (event-modifiers (elt (kbd "s-t") 0)) 0))
	     (click (elt (event-modifiers (elt (kbd "<mouse-1>") 0)) 0)))
	 (and (eq (length key) 1)
	      (seq-contains-p (event-modifiers (elt key 0)) super)
	      (not (seq-contains-p (event-modifiers (elt key 0)) click)))))

     (defun binding-without-super (key)
       (let ((super (elt (event-modifiers (elt (kbd "s-t") 0)) 0))
	     (first-key (elt key 0)))
	 (event-convert-list
	  (append
	   (seq-remove
	    (lambda (el) (eq el super))
	    (event-modifiers first-key))
	   (list (event-basic-type first-key))))))

     (defun inverse-kbd (key)
       (key-description (list key)))

     (defun gather-bindings (keymap)
       (let ((bindings '()))
	 (map-keymap
	  (lambda (evt val)
	    (if (is-super-binding-p (list evt))
		(setq bindings (cons (cons (inverse-kbd (binding-without-super (list evt))) val) bindings))))
	  keymap)
	 bindings))

     (use-package smartrep
       :straight t)

     (add-hook
      'after-init-hook
      (lambda ()
	(smartrep-define-key
	    global-map "C-c"
	  (gather-bindings global-map))))
   #+END_SRC

* Packages
** Magit
#+BEGIN_SRC emacs-lisp
  (if (gethash :magit package-overrides t)
      (use-package magit
	:straight t
	:commands magit-status magit-blame-addition
	:init
	(defadvice magit-status (around magit-fullscreen activate)
	  (window-configuration-to-register :magit-fullscreen)
	  ad-do-it
	  (delete-other-windows))
	:config
	(setq magit-branch-arguments nil
	      ;; don't put "origin-" in front of new branch names by default
	      magit-default-tracking-name-function 'magit-default-tracking-name-branch-only
	      magit-push-always-verify nil
	      ;; Get rid of the previous advice to go into fullscreen
	      magit-restore-window-configuration t)
	:bind ("C-x g" . magit-status)))
#+END_SRC

** Diff Highlight
#+BEGIN_SRC emacs-lisp
  (use-package diff-hl
  :straight t
  :config
  (global-diff-hl-mode)
  (diff-hl-margin-mode))
#+END_SRC

** Flycheck
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :straight t
    :hook ('prog-mode . #'global-flycheck-mode))
#+END_SRC
* File-type support
** YAML
#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :straight t
    :mode "\\.yml\\'")
#+END_SRC

** Thrift
#+BEGIN_SRC emacs-lisp
  (use-package thrift-mode
    :straight t)
#+END_SRC

** Lua
#+BEGIN_SRC emacs-lisp
  (use-package lua-mode
    :straight t
    :config
    (flycheck-define-checker lua-luacheck-old
      "A Lua syntax checker using luacheck.

  See URL `https://github.com/mpeterv/luacheck'."
      :command ("luacheck"
		;; "--formatter" "plain"
		;; "--codes"                   ; Show warning codes
		"--no-color"
		(option-list "--std" flycheck-luacheck-standards)
		(config-file "--config" flycheck-luacheckrc)
		;; "--filename" source-original
		;; Read from standard input
		source-original)
      :standard-input t
      :error-patterns
      ((warning line-start
		(optional (minimal-match (one-or-more not-newline)))
		":" line ":" column
		": (" (id "W" (one-or-more digit)) ") "
		(message) line-end)
       (error line-start
	      (optional (minimal-match (one-or-more not-newline)))
	      ":" line ":" column ":"
	      ;; `luacheck' before 0.11.0 did not output codes for errors, hence
	      ;; the ID is optional here
	      (optional " (" (id "E" (one-or-more digit)) ") ")
	      (message) line-end))
      :modes lua-mode)
    :hook
    (lua-mode
     .
     (lambda()
       (set (make-local-variable 'compile-command)
	    (let ((file (file-name-nondirectory buffer-file-name)))
	      (format "luacheck --no-color %s" file))))))

#+END_SRC

** Org
#+BEGIN_SRC emacs-lisp
      (use-package org
	:config
	(setq org-log-done t
	      ;; refile-related configs from https://blog.aaronbieber.com/2017/03/19/organizing-notes-with-refile.html
	      org-refile-targets '((org-agenda-files :maxlevel . 3))
	      org-refile-use-outline-path 'file
	      org-outline-path-complete-in-steps nil
	      org-refile-allow-creating-parent-nodes 'confirm
	      org-startup-folded t
	      org-agenda-log-mode-items '(closed clock state)
	      org-src-tab-acts-natively t)
	;; custom todo tags
	(setq org-todo-keywords
	      '((sequence "TODO(t!)" "IN-PROGRESS(i@/!)" "|" "DONE(d!)" "CANCELED(c@!)")
		(sequence "MEET(m@)" "|" "DONE(d!)")
		(sequence "IDEA(a!)" "|" "DONE(d!)")))
	(setq org-agenda-custom-commands
	      '(("d" "Daily agenda and all TODOs"
		 ((todo "IN-PROGRESS"
			((org-agenda-overriding-header "Unfinished tasks:")))
		  (agenda "" ((org-agenda-span 1)))
		  (tags ":refile:"
			((org-agenda-overriding-header "To refile:")))
		  (todo "TODO"
			((org-agenda-overriding-header "Open tasks:")))
		  (todo "MEET"
			((org-agenda-overriding-header "People to meet:")
			 (org-agenda-max-entries 5)))
		  (todo "IDEA"
			((org-agenda-overriding-header "Ideas:")
			 (org-agenda-max-entries 5))))
		 ((org-agenda-compact-blocks t)))
		("p" "3-week context plan"
		 ((agenda "" ((org-agenda-start-day "-7d") (org-agenda-span 21))))
		 ((org-agenda-compact-blocks t)
		  (org-agenda-include-inactive-timestamps 't)))
		("h" "last half dates"
		 ((agenda "" ((org-agenda-start-day "-6m") (org-agenda-span 183))))
		 ((org-agenda-compact-blocks t)
		  (org-agenda-include-inactive-timestamps 't)))))
	(setq helm-org-ignore-autosaves t
	      helm-org-headings-fontify t
	      helm-org-format-outline-path t
	      helm-org-show-filename t
	      helm-org-headings-max-depth 6)
	:bind (:map org-mode-map
		    ("s-r" . helm-org-agenda-files-headings)))
#+END_SRC

** ANTLR
#+BEGIN_SRC emacs-lisp
  (use-package antlr-mode
    :mode ("\\.g4\\'" . antlr-mode)
    :straight t)
#+END_SRC
** C++
#+BEGIN_SRC emacs-lisp

      (use-package lsp-mode
	:straight t
	:config
	(setq
	 lsp-ui-sideline-show-code-actions nil
	 lsp-ui-sideline-show-hover nil
	 ))
      (use-package company-lsp
	:straight t
	:config (add-to-list 'company-backends 'company-lsp))
      (use-package lsp-ui
	:straight t
	:init (add-hook 'lsp-mode-hook 'lsp-ui-mode))
      (use-package lsp-ui-flycheck
	:init (add-hook 'lsp-after-open-hook (lambda () (lsp-ui-flycheck-enable 1))))

    (use-package cquery
      :straight t
      :if
      (file-exists-p "/bin/cquery")
      :bind
      (:map c-mode-base-map
	    ("C-t h c" . cquery-call-hierarchy)
	    ("C-t h i" . cquery-inheritance-hierarchy)
	    ("C-t i" . lsp-ui-sideline-toggle-symbols-info)
	    ("C-t I". helm-imenu)
	    ("C-t h m" . cquery-member-hierarchy)
	    ("C-t ." . lsp-ui-peek-find-definitions)
	    ("C-t ?" . lsp-ui-peek-find-references))
      :preface
      (defun cquery//enable ()
	(condition-case nil
	    (lsp)
	  (user-error nil)))
      :init
      (add-hook 'c-mode-common-hook #'cquery//enable)
      (defun cquery-cache-dir (dir)
	(expand-file-name cquery-cache-dir "/home/mhj/.cquery_cache"))
      (setq cquery-cache-dir-function #'cquery-cache-dir)
      :config
      (setq
       cquery-executable "/bin/cquery"
       cquery-extra-args '("--log-file=/tmp/cq.log")
       cquery-extra-init-params '(:completion (:detailedLabel t))
       cquery-sem-highlight-method 'font-lock
       company-transformers nil
       company-lsp-async t
       company-lsp-cache-candidates nil
       xref-prompt-for-identifier '(not
				    xref-find-definitions
				    xref-find-definitions-other-window
				    xref-find-definitions-other-frame
				    xref-find-references)))

    (use-package clang-format
      :straight t
      :config
      (progn
	(defun clang-format-before-save ()
	  "Add this to .emacs to clang-format on save
   (add-hook 'before-save-hook 'clang-format-before-save)."

	  (interactive)
	  (when (eq major-mode 'c++-mode) (clang-format-buffer))))
      :hook ('before-save . #'clang-format-before-save))

  (use-package cc-mode
    :mode ("\\.h|\\.cpp" . c++-mode))
#+END_SRC
** Python
#+BEGIN_SRC emacs-lisp
  (use-package blacken
    :straight t
    :hook (python-mode . blacken-mode))
#+END_SRC

** Cython
#+BEGIN_SRC emacs-lisp
  (use-package cython-mode
    :straight t)
#+END_SRC

* Startup
Launch a server if not currently running, default to showing org daily agenda

#+BEGIN_SRC emacs-lisp
  (server-start)
  (org-agenda nil "d")
  (delete-other-windows)
#+END_SRC

* License

  My Emacs configurations written in Org mode.

  Copyright (c) 2019 Matthew Jones

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
