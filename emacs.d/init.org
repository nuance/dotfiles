#+TITLE: Emacs configuration file
#+AUTHOR: Matthew Jones
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle yes

* About

My emacs config, heavily inspired / forked from [[https://github.com/larstvei/dot-emacs]].

* Configurations
** Meta

All changes to the configuration should be done in =init.org=, *not* in
=init.el=. Any changes in the =init.el= will be overwritten by saving
=init.org=. The =init.el= in this repo should not be tracked by git, and
is replaced the first time Emacs is started (assuming it has been renamed
to =~/.emacs.d=).

Emacs can't load =.org=-files directly, but =org-mode= provides functions
to extract the code blocks and write them to a file. There are multiple
ways of handling this; like suggested by [[http://emacs.stackexchange.com/questions/3143/can-i-use-org-mode-to-structure-my-emacs-or-other-el-configuration-file][this StackOverflow post]], one
could just use =org-babel-load-file=, but I had problems with
byte-compilation. Previously I tracked both the =org.=- and =el.=-files,
but the git commits got a little messy. So here is a new approach.

When this configuration is loaded for the first time, the ~init.el~ is
the file that is loaded. It looks like this:

#+BEGIN_SRC emacs-lisp :tangle no
  ;; This file replaces itself with the actual configuration at first run.

  ;; We can't tangle without org!
  (require 'org)
  ;; Open the configuration
  (find-file (concat user-emacs-directory "init.org"))
  ;; tangle it
  (org-babel-tangle)
  ;; load it
  (load-file (concat user-emacs-directory "init.el"))
  ;; finally byte-compile it
  (byte-compile-file (concat user-emacs-directory "init.el"))
#+END_SRC

It tangles the org-file, so that this file is overwritten with the actual
configuration.

There is no reason to track the =init.el= that is generated; by running
the following command =git= will not bother tracking it:

#+BEGIN_SRC sh :tangle no
  git update-index --assume-unchanged init.el
#+END_SRC

If one wishes to make changes to the repo-version of =init.el= start
tracking again with:

#+BEGIN_SRC sh :tangle no
  git update-index --no-assume-unchanged init.el
#+END_SRC

I want lexical scoping for the init-file, which can be specified in the
header. The first line of the configuration is as follows:

#+BEGIN_SRC emacs-lisp
  ;;; -*- lexical-binding: t -*-
#+END_SRC

The =init.el= should (after the first run) mirror the source blocks in
the =init.org=. We can use =C-c C-v t= to run =org-babel-tangle=, which
extracts the code blocks from the current file into a source-specific
file (in this case a =.el=-file).

To avoid doing this each time a change is made we can add a function to
the =after-save-hook= ensuring to always tangle and byte-compile the
=org=-document after changes.

#+BEGIN_SRC emacs-lisp
  (defun tangle-init ()
    "If the current buffer is 'init.org' the code-blocks are
  tangled, and the tangled file is compiled."
    (when (or (equal (buffer-file-name)
                     (expand-file-name (concat user-emacs-directory "init.org")))
              (equal (buffer-file-name)
                     (expand-file-name (concat user-emacs-directory "private.org"))))
      ;; Avoid running hooks when tangling.
      (let ((prog-mode-hook nil))
        (org-babel-tangle)
        ;; (byte-compile-file (concat user-emacs-directory "init.el"))
        )))

  (add-hook 'after-save-hook 'tangle-init)
#+END_SRC

I sometimes want to exclude packages on certain machines, so load that.

#+BEGIN_SRC emacs-lisp
  (setq package-overrides (make-hash-table))
  (let ((overrides-file (concat user-emacs-directory "config_overrides.el")))
    (when (file-exists-p overrides-file)
      (load-file overrides-file)))
#+END_SRC

* Performance optimizations

Mostly adapted from [[https://github.com/zzamboni/dot-emacs/blob/master/init.org#performance-optimization][dot-emacs/init.org at master · zzamboni/dot-emacs]]

** Disable file handlers

#+BEGIN_SRC emacs-lisp
  (setq
   nuance/file-name-handler-alist file-name-handler-alist
   file-name-handler-alist nil)
  (add-hook 'after-init-hook (lambda () (setq file-name-handler-alist nuance/file-name-handler-alist)))
#+END_SRC

** Report startup performance

#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-startup-hook
            (lambda ()
              (message "Emacs ready in %s with %d garbage collections."
                       (format "%.2f seconds"
                               (float-time
                                (time-subtract after-init-time before-init-time)))
                       gcs-done)))
#+END_SRC

** Garbage collector tweaks
*** Init-time

#+BEGIN_SRC emacs-lisp
  (setq gc-cons-threshold most-positive-fixnum)
  (add-hook 'after-init-hook (lambda () (setq gc-cons-threshold 800000)))
#+END_SRC

*** Minibuffer

#+BEGIN_SRC emacs-lisp
  (add-hook 'minibuffer-setup-hook (lambda () (setq gc-cons-threshold most-positive-fixnum)))
  (add-hook 'minibuffer-exit-hook (lambda () (setq gc-cons-threshold 800000)))
#+END_SRC

* straight.el
** Cache SSL lookups

#+BEGIN_SRC emacs-lisp
  (customize-set-variable 'nsm-settings-file (concat user-emacs-directory "network-security.data"))
#+END_SRC

** Bootstrap straight.el

#+BEGIN_SRC emacs-lisp
  (setq straight-repository-branch "develop")

  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))

  (straight-use-package 'use-package)
#+END_SRC

* Disable nswin keybindings
I don't really want all the default super bindings (I'd prefer a simpler emacs experience).

#+BEGIN_SRC emacs-lisp
  (custom-set-variables
   '(mac-command-modifier (quote super))
   '(mac-option-modifier (quote meta)))

  (let
      ((unbind-keys
        '(
          [?\s-,]
          [?\s-']
          [?\s-`]
          [?\s-~]
          [?\s--]
          [?\s-:]
          [?\s-?]
          [?\s-^]
          [?\s-&]
          [?\s-C]
          [?\s-D]
          [?\s-E]
          [?\s-L]
          [?\s-M]
          [?\s-S]
          [?\s-a]
          ;; [?\s-c]
          [?\s-d]
          [?\s-e]
          [?\s-f]
          [?\s-g]
          [?\s-h]
          [?\s-H]
          [?\M-\s-h]
          [?\s-j]
          [?\s-k]
          [?\s-l]
          [?\s-m]
          [?\s-n]
          [?\s-o]
          [?\s-p]
          [?\s-q]
          [?\s-s]
          [?\s-t]
          [?\s-u]
          ;; [?\s-v]
          [?\s-w]
          [?\s-x]
          [?\s-y]
          [?\s-z]
          [?\s-|]
          [s-kp-bar]
          [s-right]
          [s-left]
          [home]
          [end]
          [kp-home]
          [kp-end]
          [kp-prior]
          [kp-next]
          [S-mouse-1]
          )))
    (seq-map (lambda (key) (global-unset-key key)) unbind-keys))

#+END_SRC

* Niceities
** File I/O

#+BEGIN_SRC emacs-lisp
  (set-language-environment "UTF-8")
  (set-default-coding-systems 'utf-8)

  (setq load-prefer-newer t
        save-place-file (concat user-emacs-directory "places")
        backup-directory-alist `(("." . ,(concat user-emacs-directory "backups")))
                                          ; auto-revert-interval 1            ; Refresh buffers fast
                                          ; recentf-max-saved-items 100       ; Show more recent files
        sentence-end-double-space nil       ; No double space
        vc-follow-symlinks nil)
#+END_SRC

** Disable custom

#+BEGIN_SRC emacs-lisp
  (setq custom-file (make-temp-file ""))   ; Discard customization's
#+END_SRC

** Load environment variables

#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :straight t
    :config
    (when (memq window-system '(mac ns x))
      (exec-path-from-shell-initialize)))
#+END_SRC
** Elisp helpers
#+BEGIN_SRC emacs-lisp
  ;; functional helpers
  (use-package dash
    :straight t)

  ;; string manipulation
  (use-package s
    :straight t)

  ;; filepath manipulation
  (use-package f
    :straight t)
#+END_SRC

* UI Appearance
** UI Interaction

#+BEGIN_SRC emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
  (setq apropos-do-all t
        echo-keystrokes 0.1               ; Show keystrokes asap
        inhibit-startup-message t         ; No splash screen please
        initial-scratch-message nil)      ; Clean scratch buffer
#+END_SRC

** Bell

#+BEGIN_SRC emacs-lisp
  (setq visible-bell t
        ring-bell-function
        (lambda ()
          (let ((orig-fg (face-foreground 'mode-line)))
            (set-face-foreground 'mode-line "#F2804F")
            (run-with-idle-timer 0.1 nil
                                 (lambda (fg) (set-face-foreground 'mode-line fg))
                                 orig-fg)))
        inhibit-startup-echo-area-message t)
#+END_SRC

** Cursor

#+BEGIN_SRC emacs-lisp
  (setq cursor-type 'hbar)
  (blink-cursor-mode 0)
#+END_SRC

** Highlight line
#+BEGIN_SRC emacs-lisp
  (global-hl-line-mode +1)
#+END_SRC

** Minimal UI

#+BEGIN_SRC emacs-lisp
  (if (boundp 'toggle-frame-fullscreen) (toggle-frame-fullscreen))
  (if (boundp 'scroll-bar-mode) (scroll-bar-mode 0))
  (if (boundp 'tool-bar-mode) (tool-bar-mode 0))
  (if (boundp 'menu-bar-mode) (menu-bar-mode 0))
#+END_SRC

** Native fullscreen for emacs-mac

#+BEGIN_SRC emacs-lisp
  (when (eq window-system 'mac)
    (defun mac-fullscreen ()
      (interactive)
      (let ((fullscreen (frame-parameter nil 'fullscreen)))
        (if (memq fullscreen '(fullscreen fullboth))
            (let ((fullscreen-restore (frame-parameter nil 'fullscreen-restore)))
              (if (memq fullscreen-restore '(maximized fullheight fullwidth))
                  (set-frame-parameter nil 'fullscreen fullscreen-restore)
                (set-frame-parameter nil 'fullscreen nil)))
          (modify-frame-parameters
           nil `((fullscreen . fullscreen) (fullscreen-restore . ,fullscreen))))))

    (bind-key "C-x 5 4" 'mac-fullscreen))
#+END_SRC

** Doom-modeline

#+BEGIN_SRC emacs-lisp
  (use-package doom-modeline
    :straight t
    :hook (after-init . doom-modeline-mode)
    :config
    (column-number-mode 1)
    (setq
     doom-modeline-minor-modes nil
     doom-modeline-buffer-encoding nil
     doom-modeline-height 1)
    (set-face-attribute 'mode-line nil :height 110)
    (set-face-attribute 'mode-line-inactive nil :height 110))
#+END_SRC

** Line numbering
#+BEGIN_SRC emacs-lisp
  (use-package nlinum
    :straight t
    :commands global-nlinum-mode
    :config (setq nlinum-highlight-current-line t)
    :hook ('prog-mode . #'nlinum-mode))
#+END_SRC

** Matching parens highlight
#+BEGIN_SRC emacs-lisp
  (show-paren-mode)
#+END_SRC

** Light / Dark theme toggle
I'd like to toggle between light & dark themes.

*** Dark: doom-gruvbox
#+BEGIN_SRC emacs-lisp
  (use-package doom-themes
    :straight t
    :config
    (load-theme 'doom-gruvbox t)
    (doom-themes-org-config))

  (defvar dark-theme 'doom-gruvbox)
#+END_SRC

*** Light: Gruvbox-light-hard
#+BEGIN_SRC emacs-lisp
  (use-package doom-themes
    :straight t)

  (defvar light-theme 'doom-tomorrow-day)
#+END_SRC

*** Toggle
Default to dark theme, but make it easy to switch.

#+BEGIN_SRC emacs-lisp
  (defvar dark-mode t)

  (defun toggle-theme ()
    (interactive)
    (progn
      (disable-theme (if dark-mode dark-theme light-theme))
      (load-theme (if dark-mode light-theme dark-theme) t)
      (setq dark-mode (not dark-mode))
      (adapt-theme-org-colors)))
#+END_SRC

*** MacOS dark mode

#+BEGIN_SRC emacs-lisp :tangle no
  (when (eq system-type 'darwin)
    (defun nuance/dark-mode-p ()
      (not (string-equal
            (shell-command-to-string "printf %s \"$( osascript -e \'tell application \"System Events\" to tell appearance preferences to return dark mode\' )\"")
            "false")))

    (add-hook
     'after-init-hook
     (lambda ()
       (when (not (nuance/dark-mode-p)) (toggle-theme))))

    (run-with-idle-timer
     10 t
     (lambda ()
       (when (not (eq dark-mode (nuance/dark-mode-p)))
         (toggle-theme)))))
#+END_SRC

** Fixed-width font
#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'default nil
                      :family "IBM Plex Mono"
                      :height 110
                      :weight 'normal
                      :width 'normal)
#+END_SRC

** Set titlebar color

#+BEGIN_SRC emacs-lisp
  (when (eq system-type 'darwin)
    (use-package ns-auto-titlebar
      :straight t
      :config
      (ns-auto-titlebar-mode)))
#+END_SRC

* UI Interaction
** Helm
#+BEGIN_SRC emacs-lisp
  (use-package helm
    :straight t
    :demand t
    :bind (([remap execute-extended-command] . 'helm-M-x) ;; M-x
           ([remap switch-to-buffer] . 'helm-mini) ;; C-x b
           ([remap bookmark-jump] . 'helm-filtered-bookmarks) ;; C-x r b
           ([remap find-file] . 'helm-find-files) ;; C-x C-f
           ([remap eval-expression] . 'helm-eval-expression-with-eldoc) ;; M-;
           ("s-e" . 'helm-all-mark-rings)
           ("s-p" . 'helm-etags-select)
           ("s-t" . 'helm-buffers-list)
           ("s-;" . 'helm-calcul-expression)
           ("s-o" . 'helm-moccur-all)
           ("s-R" . 'helm-moccur-org)
           ([remap yank-pop] . 'helm-show-kill-ring)) ;; M-y
    :config (progn (helm-mode 1)
                   (helm-autoresize-mode t)
                   (setq helm-M-x-fuzzy-match                  t
                         helm-bookmark-show-location           t
                         helm-buffers-fuzzy-matching           t
                         helm-completion-in-region-fuzzy-match t
                         helm-file-cache-fuzzy-match           t
                         helm-imenu-fuzzy-match                t
                         helm-mode-fuzzy-match                 t
                         helm-locate-fuzzy-match               t
                         helm-quick-update                     t
                         helm-recentf-fuzzy-match              t
                         helm-semantic-fuzzy-match             t
                         helm-etags-fuzzy-match                t
                         helm-etags-match-part-only            'all
                         helm-split-window-inside-p t))
    (require 'seq)

    (defun helm-moccur-all ()
      (interactive)
      (helm-multi-occur-1 (seq-filter 'buffer-file-name (buffer-list))))

    (defun helm-moccur-org ()
      (interactive)
      (helm-multi-occur-1 (seq-filter (lambda (buf) (and (buffer-file-name buf) (with-current-buffer buf (eq major-mode 'org-mode)))) (buffer-list)))))

  (use-package helm-xref
    :straight t
    :config
    (setq xref-show-xrefs-function 'helm-xref-show-xrefs))

  (use-package helm-descbinds
    :straight t
    :config (helm-descbinds-mode))
#+END_SRC

** Posframe

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package helm-posframe :straight t
    :when (eq (window-system) 'ns)
    :config
    (setq
     helm-posframe-poshandler 'posframe-poshandler-frame-top-center
     helm-posframe-width 100
     helm-posframe-height 100
     helm-posframe-parameters '((internal-border-width . 10)))
    (helm-posframe-enable))
#+END_SRC

** Aggressive Indent

#+BEGIN_SRC emacs-lisp
  (use-package aggressive-indent
    :straight t
    :config
    (global-aggressive-indent-mode 1))
#+END_SRC

** Company
#+BEGIN_SRC emacs-lisp
  (use-package company
    :straight t
    :init (setq
           company-idle-delay 0.1
           company-minimum-prefix-length 3)
    :config
    (global-company-mode)
    (add-to-list 'company-backends 'company-dabbrev)
    (add-to-list 'company-backends 'company-etags)
    (add-to-list 'company-frontends 'company-tng-frontend)
    (setq company-dabbrev-downcase nil))

  (use-package company-quickhelp
    :straight t
    :init (setq company-quickhelp-delay 0.1)
    :config (company-quickhelp-mode))

  (use-package company-box
    :straight t
    :hook (company-mode . company-box-mode)
    :config
    (defun company-box-icons--lsp (candidate)
      (-when-let* ((lsp-item (or (get-text-property 0 'lsp-completion-item candidate)
                                 (get-text-property 0 'eglot--lsp-item candidate)))
                   (kind-num (if (hash-table-p lsp-item) (gethash "kind" lsp-item)
                               (plist-get lsp-item :kind))))
        (alist-get kind-num company-box-icons--lsp-alist))))
#+END_SRC

** Default to regexp search
#+BEGIN_SRC emacs-lisp
  (global-set-key [remap isearch-forward] 'isearch-forward-regexp) ;; C-s
  (global-set-key [remap isearch-backward] 'isearch-backward-regexp) ;; C-r
#+END_SRC
** Sublime-like
*** Automatically add newlines at EOF
#+BEGIN_SRC emacs-lisp
  (setq require-final-newline t)
#+END_SRC
*** Disable tab indentation

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
#+END_SRC

*** Remove trailing whitespace
#+BEGIN_SRC emacs-lisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC
*** Expand region
#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :straight t
    :bind (("s-f" . 'er/expand-region)
           ("s-F" . 'er/contract-region)))
#+END_SRC
*** Multiple cursors
#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :straight t
    :config
    (defun select-symbol (arg)
      "Sets the region to the symbol under the point"
      (interactive "p")
      (if (region-active-p) (mc/mark-next-like-this arg) (er/mark-symbol)))
    (defun mark-all-like-symbol (arg)
      (interactive "p")
      (progn
        (unless (region-active-p) (er/mark-symbol))
        (mc/mark-all-like-this)))
    (add-to-list 'mc/unsupported-minor-modes 'company-mode)
    (add-to-list 'mc/unsupported-minor-modes 'company-quickhelp-mode)
    (add-to-list 'mc/unsupported-minor-modes 'eldoc-mode)
    (add-to-list 'mc/unsupported-minor-modes 'flycheck-mode)
    (add-to-list 'mc/unsupported-minor-modes 'helm-mode)
    (add-to-list 'mc/unsupported-minor-modes 'lsp-ui-doc-mode)
    (add-to-list 'mc/unsupported-minor-modes 'lsp-ui-sideline-mode)
    (add-to-list 'mc/unsupported-minor-modes 'lsp-ui-mode)
    :bind (("s-L" . 'mc/edit-lines)
           ("s-d" . 'select-symbol)
           ("s-D" . 'mark-all-like-symbol)
           ("s-<mouse-1>" . 'mc/add-cursor-on-click)))
#+END_SRC
*** Comment line / region
#+BEGIN_SRC emacs-lisp
  (defun comment-line-or-region (beg end)
    "Comment a region or the current line."
    (interactive "*r")
    (save-excursion
      (if (region-active-p)
          (comment-or-uncomment-region beg end)
        (comment-line 1))))

  (global-set-key (kbd "C-\\") 'comment-line-or-region)
  (global-set-key (kbd "s-/") 'comment-line-or-region)
#+END_SRC
*** Select whole buffer
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "s-a") 'mark-whole-buffer)
#+END_SRC
*** Compilation mode tweaks
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "s-B") 'compile)
  (global-set-key (kbd "s-b") 'recompile)

  (setq compilation-scroll-output 'first-error)
  (use-package ansi-color
    :config
    (defun colorize-compilation-buffer ()
      (read-only-mode)
      (ansi-color-apply-on-region compilation-filter-start (point))
      (read-only-mode))
    :hook ('compilation-filter . #'colorize-compilation-buffer))
#+END_SRC

*** Indent / Dedent
#+BEGIN_SRC emacs-lisp
  (defun dedent (start end)
    (interactive "*r")
    (indent-rigidly start end (- tab-width)))

  (defun indent (start end)
    (interactive "*r")
    (indent-rigidly start end tab-width))

  (global-set-key (kbd "s-[") 'dedent)
  (global-set-key (kbd "s-]") 'indent)
#+END_SRC
*** Guess indentation settings
#+BEGIN_SRC emacs-lisp
  (use-package dtrt-indent
    :straight t
    :config
    (dtrt-indent-mode 1)
    )
#+END_SRC
*** Window navigation
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-j") 'previous-multiframe-window)
  (global-set-key (kbd "M-k") 'other-window)

  (use-package ace-window
    :straight t
    :demand t
    :config
    (defun switch-to-nth-window (window-num)
      (let ((window (nth window-num (aw-window-list))))
        (when window (select-window window))))
    :bind (
           ("s-1" . (lambda () (interactive) (switch-to-nth-window 0)))
           ("s-2" . (lambda () (interactive) (switch-to-nth-window 1)))
           ("s-3" . (lambda () (interactive) (switch-to-nth-window 2)))
           ("s-4" . (lambda () (interactive) (switch-to-nth-window 3)))
           ("s-5" . (lambda () (interactive) (switch-to-nth-window 4)))
           ("s-6" . (lambda () (interactive) (switch-to-nth-window 5)))
           ("s-7" . (lambda () (interactive) (switch-to-nth-window 6)))
           ("s-8" . (lambda () (interactive) (switch-to-nth-window 7)))
           ("s-9" . (lambda () (interactive) (switch-to-nth-window 8)))
           ("s-0" . (lambda () (interactive) (switch-to-nth-window 9)))))
#+END_SRC
*** Go to line
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "s-l") 'goto-line)
#+END_SRC

*** Upcase / downcase
#+BEGIN_SRC emacs-lisp
  (put 'upcase-region 'disabled nil)
  (put 'downcase-region 'disabled nil)
  ;; (global-set-key (kbd "s-k s-u") 'upcase-region)
  ;; (global-set-key (kbd "s-k s-l") 'downcase-region)
#+END_SRC
*** Electric pair
#+BEGIN_SRC emacs-lisp
  (electric-pair-mode 1)
#+END_SRC
*** Auto revert
#+BEGIN_SRC emacs-lisp
  (global-auto-revert-mode t)
#+END_SRC
*** s-w is kill-buffer

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "s-w") 'kill-this-buffer)
#+END_SRC

** CTags
Auto-revert to new tags file
#+BEGIN_SRC emacs-lisp
  (setq tags-revert-without-query 1)
#+END_SRC
** Map Super-* to C-c * + smartrep

#+BEGIN_SRC emacs-lisp
  (defun is-super-binding-p (key)
    (let ((super (elt (event-modifiers (elt (kbd "s-t") 0)) 0))
          (click (elt (event-modifiers (elt (kbd "<mouse-1>") 0)) 0)))
      (and (eq (length key) 1)
           (seq-contains (event-modifiers (elt key 0)) super)
           (not (seq-contains (event-modifiers (elt key 0)) click)))))

  (defun binding-without-super (key)
    (let ((super (elt (event-modifiers (elt (kbd "s-t") 0)) 0))
          (first-key (elt key 0)))
      (event-convert-list
       (append
        (seq-remove
         (lambda (el) (eq el super))
         (event-modifiers first-key))
        (list (event-basic-type first-key))))))

  (defun inverse-kbd (key)
    (key-description (list key)))

  (defun gather-bindings (keymap prefix)
    (let ((bindings '()))
      (map-keymap
       (lambda (evt val)
         (if (and
              val                              ;; this binding has to have a target (eg it wasn't unset)
              (is-super-binding-p (list evt))) ;; it needs to include the super key
             (let ((new-binding (binding-without-super (list evt))))
               (if (not (global-key-binding (kbd (concat prefix " " (inverse-kbd (list new-binding))))))
                   (setq bindings (cons (cons (inverse-kbd new-binding) val) bindings))))))
       keymap)
      bindings))

  (use-package smartrep
    :straight t)

  (add-hook
   'after-init-hook
   (lambda ()
     (smartrep-define-key
         global-map "C-c"
       (gather-bindings global-map "C-c"))))
#+END_SRC

** Ansi-term improvements
From https://echosa.github.io/blog/2012/06/06/improving-ansi-term/

*** Close terminal windows when shell exits

#+BEGIN_SRC emacs-lisp
  (defadvice term-sentinel (around my-advice-term-sentinel (proc msg))
    (if (memq (process-status proc) '(signal exit))
        (let ((buffer (process-buffer proc)))
          ad-do-it
          (kill-buffer buffer))
      ad-do-it))
  (ad-activate 'term-sentinel)
#+END_SRC

*** Default to /bin/bash

#+BEGIN_SRC emacs-lisp
  (setq shell-command-switch "-lc")
  (defvar my-term-shell "/bin/bash")
  (defadvice ansi-term (before force-bash)
    (interactive (list my-term-shell)))
  (ad-activate 'ansi-term)
#+END_SRC

*** Use utf8

#+BEGIN_SRC emacs-lisp
  (defun my-term-use-utf8 ()
    (set-buffer-process-coding-system 'utf-8-unix 'utf-8-unix))
  (add-hook 'term-exec-hook 'my-term-use-utf8)
#+END_SRC

*** Make URLs clickable

#+BEGIN_SRC emacs-lisp
  (add-hook 'term-mode-hook (lambda () (goto-address-mode)))
#+END_SRC

*** Handle C-y

#+BEGIN_SRC emacs-lisp
  (defun my-term-paste (&optional string)
    (interactive)
    (process-send-string
     (get-buffer-process (current-buffer))
     (if string string (current-kill 0))))

  (add-hook 'term-mode-hook (lambda () (define-key term-raw-map "\C-y" 'my-term-paste)))
#+END_SRC

*** Switch to terminal

#+BEGIN_SRC emacs-lisp
  (defun nuance-toggle-term ()
    (interactive)
    (if (get-buffer "*ansi-term*")
        (pop-to-buffer "*ansi-term*" 'display-buffer-reuse-window)
      (ansi-term "/bin/bash")))

  (global-set-key (kbd "s-T") 'nuance-toggle-term)
#+END_SRC

** Reload all buffers

#+BEGIN_SRC emacs-lisp
  (defun nuance/revert-all-buffers ()
    (interactive)
    (let (file)
      (dolist (buf  (buffer-list))
        (setq path  (buffer-file-name buf))
        (when (and path (file-readable-p path) (not (buffer-modified-p buf)))
          (with-current-buffer buf
            (with-demoted-errors "Error: %S" (revert-buffer t t)))))))
#+END_SRC

* Packages
** Magit
#+BEGIN_SRC emacs-lisp
  (if (gethash :magit package-overrides t)
      (use-package magit
        :straight t
        :commands magit-status magit-blame-addition
        :config
        (setq magit-branch-arguments nil
              ;; don't put "origin-" in front of new branch names by default
              magit-default-tracking-name-function 'magit-default-tracking-name-branch-only
              magit-push-always-verify nil
              ;; Get rid of the previous advice to go into fullscreen
              magit-restore-window-configuration t)
        :bind ("C-x g" . magit-status)))
#+END_SRC

** Diff Highlight
#+BEGIN_SRC emacs-lisp
  (use-package diff-hl
    :straight t
    :config
    (global-diff-hl-mode)
    (diff-hl-margin-mode)
    (diff-hl-flydiff-mode))
#+END_SRC

** Flycheck
#+BEGIN_SRC emacs-lisp
  (use-package flymake
    :straight t
    :bind (("M-n" . flymake-goto-next-error)
           ("M-p" . flymake-goto-prev-error)))

  (use-package flycheck
    :straight t
    :hook ('prog-mode . #'flycheck-mode))

  (use-package flymake-diagnostic-at-point
    :straight t
    :hook ('flymake-mode-hook . #'flymake-diagnostic-at-point-mode)
    :config (setq
             flymake-diagnostic-at-point-error-prefix ""
             flymake-diagnostic-at-point-display-diagnostic-function 'flymake-diagnostic-at-point-display-minibuffer))
#+END_SRC
** Snippets

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet :straight t :config (yas-global-mode))
#+END_SRC

** LSP
I'm trying out an alternate to lsp-mode, so this is currently disabled

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package lsp-mode
    :straight t
    :config
    (setq
     lsp-ui-sideline-show-code-actions nil
     lsp-ui-sideline-show-hover nil
     ))
  (use-package company-lsp
    :straight t
    :config (add-to-list 'company-backends 'company-lsp))
  (use-package lsp-ui
    :straight t
    :init (add-hook 'lsp-mode-hook 'lsp-ui-mode))
  (use-package lsp-ui-flycheck
    :init (add-hook 'lsp-after-open-hook (lambda () (lsp-ui-flycheck-enable 1))))
#+END_SRC

Instead, I'm trying to use eglot

#+BEGIN_SRC emacs-lisp
  (use-package eglot
    :straight t
    :config
    (setq-default
     eglot-workspace-configuration '((:gopls . (:usePlaceholders t))))
    :hook ((python-mode c++-mode c-mode go-mode rust-mode) . 'eglot-ensure))
#+END_SRC

** Bug hunter
Bugs crop up in this file, so pull in some code to help bisect them.

#+BEGIN_SRC emacs-lisp
  (use-package bug-hunter :straight t)
#+END_SRC

Use this by invoking `M-x bug-hunter-init-file` and following instructions.

** Projectile

Use projectile to index git repos.

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :straight t
    :config
    (projectile-mode))

  (use-package helm-projectile
    :straight t
    :init (use-package helm-rg :straight t)
    :bind (([remap helm-etags-select] . 'helm-projectile-find-file-dwim))
    (("s-F" . 'helm-projectile-rg)))
#+END_SRC

** Org
*** Installation
#+BEGIN_SRC emacs-lisp
  (use-package org
    :straight org-plus-contrib
    :bind (
           ("C-c c" . org-capture)
           ("C-c l" . org-store-link)
           :map org-mode-map
           ("C-c g" . org-mac-grab-link)
           ("s-b" . org-babel-execute-src-block)
           ("s-B" . org-babel-execute-buffer)
           ("s-." . org-toggle-narrow-to-subtree)))

  (use-package helm-org
    :straight t
    :config
    (setq helm-org-ignore-autosaves t
          helm-org-headings-fontify t
          helm-org-format-outline-path t
          helm-org-show-filename t
          helm-org-headings-max-depth 6)
    :bind ("s-r" . helm-org-agenda-files-headings))
#+END_SRC
*** Agenda

#+BEGIN_SRC emacs-lisp
  (defun nuance/current-org-buffer ()
    (delq nil
          (mapcar (lambda (buffer)
                    (buffer-file-name buffer))
                  (org-buffer-list 'files t))))

  (setq
   org-agenda-files '("~/org" "~/.emacs.d/init.org" "~/.emacs.d/private.org" "~/.notes")
   org-log-done t
   org-enforce-todo-dependencies t
   ;; refile-related configs from https://blog.aaronbieber.com/2017/03/19/organizing-notes-with-refile.html
   org-refile-targets '((org-agenda-files :maxlevel . 3) (nuance/current-org-buffer :maxlevel . 3))
   org-refile-use-outline-path 'file
   org-outline-path-complete-in-steps nil
   org-refile-allow-creating-parent-nodes 'confirm
   org-startup-folded t
   org-agenda-log-mode-items '(closed clock state)
   org-src-tab-acts-natively t
   org-agenda-include-diary t)
  ;; custom todo tags
  (setq org-todo-keywords
        '((sequence "TODO(t!)" "IN-PROGRESS(i@/!)" "|" "DONE(d!)" "CANCELED(c@!)")))
  (setq org-agenda-custom-commands
        '(("f" "Today"
           ((agenda "" ((org-agenda-span 1)))
            (tags ":today:" ((org-agenda-overriding-header "Today"))))
           ((org-agenda-compact-blocks t)))
          ("d" "Daily agenda and all TODOs"
           ((todo "IN-PROGRESS"
                  ((org-agenda-overriding-header "Unfinished tasks:")))
            (agenda "" ((org-agenda-span 1)))
            (tags ":refile:"
                  ((org-agenda-overriding-header "To refile:")))
            (todo "TODO"
                  ((org-agenda-overriding-header "Open tasks:"))))
           ((org-agenda-compact-blocks t)))
          ("p" "3-week context plan"
           ((agenda "" ((org-agenda-start-day "-7d") (org-agenda-span 21))))
           ((org-agenda-compact-blocks t)
            (org-agenda-include-inactive-timestamps 't)))
          ("h" "last half dates"
           ((agenda "" ((org-agenda-start-day "-6m") (org-agenda-span 183))))
           ((org-agenda-compact-blocks t)
            (org-agenda-include-inactive-timestamps 't)))))
#+END_SRC

*** Prettier org mode
Adapted from https://zzamboni.org/post/beautifying-org-mode-in-emacs/

#+BEGIN_SRC emacs-lisp
  (defun adapt-theme-org-colors ()
    (let* ((variable-tuple
            (cond ((x-list-fonts "IBM Plex Sans") '(:font "IBM Plex Sans"))
                  ((x-list-fonts "SF Pro Text") '(:font "SF Pro Text"))
                  ((x-family-fonts "Sans Serif")    '(:family "Sans Serif"))
                  (nil (warn "Cannot find a Sans Serif Font."))))
           (base-font-color     (face-foreground 'default nil 'default))
           (headline           `(:inherit default :weight bold :foreground ,base-font-color)))

      (custom-theme-set-faces
       'user
       `(org-level-8 ((t (,@headline ,@variable-tuple))))
       `(org-level-7 ((t (,@headline ,@variable-tuple))))
       `(org-level-6 ((t (,@headline ,@variable-tuple))))
       `(org-level-5 ((t (,@headline ,@variable-tuple))))
       `(org-level-4 ((t (,@headline ,@variable-tuple :height 1.1))))
       `(org-level-3 ((t (,@headline ,@variable-tuple :height 1.2))))
       `(org-level-2 ((t (,@headline ,@variable-tuple :height 1.3))))
       `(org-level-1 ((t (,@headline ,@variable-tuple :height 1.4))))
       `(org-document-title ((t (,@headline ,@variable-tuple :height 1.5 :underline nil))))))

    (custom-theme-set-faces
     'user
     '(variable-pitch ((t (:family "IBM Plex Sans" :height 120 :weight light))))
     '(fixed-pitch ((t ( :family "IBM Plex Mono" :slant normal :weight normal :height 110 :width normal)))))
    (add-hook 'org-mode-hook 'variable-pitch-mode)
    (add-hook 'org-mode-hook 'visual-line-mode)
    (add-hook 'org-mode-hook 'org-indent-mode)
    (custom-theme-set-faces
     'user
     '(org-block                 ((t (:inherit fixed-pitch))))
     '(org-document-info         ((t (:foreground "dark orange"))))
     '(org-document-info-keyword ((t (:inherit (shadow fixed-pitch)))))
     '(org-link                  ((t (:foreground "royal blue" :underline t))))
     '(org-meta-line             ((t (:inherit (font-lock-comment-face fixed-pitch)))))
     '(org-property-value        ((t (:inherit fixed-pitch))) t)
     '(org-special-keyword       ((t (:inherit (font-lock-comment-face fixed-pitch)))))
     '(org-tag                   ((t (:inherit (shadow fixed-pitch) :weight bold :height 0.8))))
     '(org-verbatim              ((t (:inherit (shadow fixed-pitch)))))
     '(org-indent                ((t (:inherit (org-hide fixed-pitch)))))))
  (when window-system
    (progn
      (setq org-hide-emphasis-markers t)
      (font-lock-add-keywords 'org-mode
                              '(("^ *\\([-]\\) "
                                 (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
      (use-package org-bullets
        :straight t
        :config
        (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
      (adapt-theme-org-colors)
      ))
#+END_SRC

*** Window interaction
Don't mess up the window layout when editing code blocks.

#+BEGIN_SRC emacs-lisp
  (setq org-src-window-setup 'current-window)
#+END_SRC
** Jupyter
Support for working with jupyter notebooks, mostlfy focused on interaction with org / org-babel.

#+BEGIN_SRC emacs-lisp
  (use-package jupyter
    :straight t
    :config
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((latex . t)
       (python . t)
       (emacs-lisp . t)
       (jupyter . t)))
    (setq org-babel-default-header-args:jupyter-python '((:async . "yes")
                                                         (:session . "py")
                                                         (:kernel . "python3")))
    (org-babel-jupyter-override-src-block "python"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq safe-local-variable-values '((org-confirm-babel-evaluate)))
#+END_SRC

** Tramp

#+BEGIN_SRC emacs-lisp
  (use-package tramp
    :config
    (setq
     tramp-auto-save-directory "/tmp"
     tramp-ssh-controlmaster-options ""
     tramp-inline-compress-start-size (* 64 1024)))
#+END_SRC

** Direnv
#+BEGIN_SRC emacs-lisp
  (use-package direnv
    :straight t
    :config
    (setq direnv-always-show-summary t)
    (direnv-mode)
    :hook ('eshell-directory-change-hook . #'direnv-update-directory-environment))
#+END_SRC

** GC Magic Hack

Optimize GC usage

#+BEGIN_SRC emacs-lisp
  (use-package gcmh :straight t)
#+END_SRC

** ElDoc

#+BEGIN_SRC emacs-lisp
  (use-package eldoc :hook (prog-mode . eldoc-mode))
#+END_SRC

** Formatter

 Generic tramp-friendly helper for formatters that read from stdin / write to stdout

 #+BEGIN_SRC emacs-lisp
   (use-package async :straight t)

   (defun nuance/delete-file-async (path) (async-start (lambda () (delete-file path nil)) 'ignore))

   (defun nuance/format-buffer (prefix-arg tmp-buf-name binary &optional failure-p &rest args)
     (if (and (not prefix-arg) (> (buffer-size) tramp-inline-compress-start-size)) (message "Skipping formatting for large file")
       (let ((tmp-stdin-path (make-nearby-temp-file (format "%s--stdin" tmp-buf-name)))
             (tmp-stdout-buf (generate-new-buffer (format "*%s--stdout*" tmp-buf-name)))
             (tmp-stderr-buf (generate-new-buffer (format "*%s--stderr*" tmp-buf-name)))
             (input-buffer (current-buffer))
             (failure-check (if failure-p failure-p (lambda (errno stdout-buf stderr-buf) (/= errno 0)))))
         (write-region nil nil tmp-stdin-path)
         (let ((errno (apply 'process-file binary tmp-stdin-path (list tmp-stdout-buf tmp-stderr-buf) nil args)))
           (if (funcall failure-check errno tmp-stdout-buf tmp-stderr-buf)
             (progn (replace-buffer-contents tmp-stdout-buf)
                    (nuance/delete-file-async tmp-stdin-path)
                    (kill-buffer tmp-stdout-buf)
                    (kill-buffer tmp-stderr-buf)))))))
 #+END_SRC

*** autobuildify

 #+BEGIN_SRC emacs-lisp
   (defvar autobuildify--buildifier-binary
     "buildifier"
     "Path to Buildifier binary.")

   (defun autobuildify--run-buildifier-on-current-file (arg)
     (interactive "P")
     (nuance/format-buffer arg "buildifier" autobuildify--buildifier-binary))

   (defun autobuildify--save-hook ()
     (let ((fname (buffer-file-name)))
       (if (and fname
                (string-match "/\\(TARGETS\\|BUILD\\)$" fname))
           (autobuildify--run-buildifier-on-current-file nil))))

   (add-hook 'before-save-hook 'autobuildify--save-hook)
 #+END_SRC

*** clang-format

 #+BEGIN_SRC emacs-lisp
   (defun clang-format-buffer (arg)
     (interactive "P")
     (nuance/format-buffer arg
      "clang-format" "clang-format" nil "-style=file" (format "-assume-filename=%s" (file-local-name (buffer-file-name)))))

   (defun clang-format--save-hook ()
     "Add this to .emacs to clang-format on save
   (add-hook 'before-save-hook 'clang-format-before-save)."
     (interactive)
     (when (eq major-mode 'c++-mode) (clang-format-buffer nil)))

   (add-hook 'before-save-hook 'clang-format--save-hook)
 #+END_SRC

*** blacken

 #+BEGIN_SRC emacs-lisp
   (defun blacken-buffer (arg)
     (interactive "P")
     (nuance/format-buffer arg "black" "black" nil "-" "-q"))

   (defun blacken--save-hook ()
     "Add this to .emacs to blacken on save
   (add-hook 'before-save-hook blacken-before-save)."
     (interactive)
     (when (eq major-mode 'python-mode) (blacken-buffer nil)))

   (add-hook 'before-save-hook 'blacken--save-hook)
 #+END_SRC

* File-type support
** Generic prog-mode improvements
*** Toggleable function narrowing

#+BEGIN_SRC emacs-lisp
  (defun nuance/toggle-narrow-to-defun ()
    (interactive)
    (if (buffer-narrowed-p) (widen) (narrow-to-defun)))


  (use-package prog-mode
    :bind (:map prog-mode-map ("s-." . nuance/toggle-narrow-to-defun)))
#+END_SRC

** YAML
#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :straight t
    :mode "\\.yml\\'")
#+END_SRC

** Thrift
#+BEGIN_SRC emacs-lisp
  (use-package thrift-mode
    :straight t)
#+END_SRC

** Protobuf

#+BEGIN_SRC emacs-lisp
  (use-package protobuf-mode
    :straight t)
#+END_SRC

** Lua
#+BEGIN_SRC emacs-lisp
  (use-package lua-mode
    :straight t
    :config
    (flycheck-define-checker lua-luacheck-old
                             "A Lua syntax checker using luacheck.

  See URL `https://github.com/mpeterv/luacheck'."
                             :command ("luacheck"
                                       ;; "--formatter" "plain"
                                       ;; "--codes"                   ; Show warning codes
                                       "--no-color"
                                       (option-list "--std" flycheck-luacheck-standards)
                                       (config-file "--config" flycheck-luacheckrc)
                                       ;; "--filename" source-original
                                       ;; Read from standard input
                                       source-original)
                             :standard-input t
                             :error-patterns
                             ((warning line-start
                                       (optional (minimal-match (one-or-more not-newline)))
                                       ":" line ":" column
                                       ": (" (id "W" (one-or-more digit)) ") "
                                       (message) line-end)
                              (error line-start
                                     (optional (minimal-match (one-or-more not-newline)))
                                     ":" line ":" column ":"
                                     ;; `luacheck' before 0.11.0 did not output codes for errors, hence
                                     ;; the ID is optional here
                                     (optional " (" (id "E" (one-or-more digit)) ") ")
                                     (message) line-end))
                             :modes lua-mode)
    :hook
    (lua-mode
     .
     (lambda()
       (set (make-local-variable 'compile-command)
            (let ((file (file-name-nondirectory buffer-file-name)))
              (format "luacheck --no-color %s" file))))))

#+END_SRC

** ANTLR
#+BEGIN_SRC emacs-lisp
  (use-package antlr-mode
    :mode ("\\.g4\\'" . antlr-mode)
    :straight t)
#+END_SRC
** C++

CQuery is disabled, but I still want C++ support

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package cquery
    :straight t
    :if
    (file-exists-p "/bin/cquery")
    :bind
    (:map c-mode-base-map
          ("C-t h c" . cquery-call-hierarchy)
          ("C-t h i" . cquery-inheritance-hierarchy)
          ("C-t i" . lsp-ui-sideline-toggle-symbols-info)
          ("C-t I". helm-imenu)
          ("C-t h m" . cquery-member-hierarchy)
          ("C-t ." . lsp-ui-peek-find-definitions)
          ("C-t ?" . lsp-ui-peek-find-references))
    :preface
    (defun cquery//enable ()
      (condition-case nil
          (lsp)
        (user-error nil)))
    :init
    (add-hook 'c-mode-common-hook #'cquery//enable)
    (defun cquery-cache-dir (dir)
      (expand-file-name cquery-cache-dir "/home/mhj/.cquery_cache"))
    (setq cquery-cache-dir-function #'cquery-cache-dir)
    :config
    (setq
     cquery-executable "/bin/cquery"
     cquery-extra-args '("--log-file=/tmp/cq.log")
     cquery-extra-init-params '(:completion (:detailedLabel t))
     cquery-sem-highlight-method 'font-lock
     company-transformers nil
     company-lsp-async t
     company-lsp-cache-candidates nil
     xref-prompt-for-identifier '(not
                                  xref-find-definitions
                                  xref-find-definitions-other-window
                                  xref-find-definitions-other-frame
                                  xref-find-references)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package clang-format
    :straight t
    :config
    (progn
      (defun clang-format-before-save ()
        "Add this to .emacs to clang-format on save
   (add-hook 'before-save-hook 'clang-format-before-save)."

        (interactive)
        (when (eq major-mode 'c++-mode) (clang-format-buffer))))
    :hook ('before-save . #'clang-format-before-save))

  (use-package cc-mode
    :mode ("\\.h|\\.cpp" . c++-mode))
#+END_SRC
** Python
#+BEGIN_SRC emacs-lisp
  (use-package blacken
    :straight t
    :hook (python-mode . blacken-mode))

  (setq
   flycheck-python-pycompile-executable "python3"
   flycheck-python-flake8-executable "flake8")

  (use-package virtualenvwrapper
    :straight t
    :init (setq venv-location (expand-file-name "~/.pyenv/versions"))
    :config (venv-initialize-interactive-shells))
#+END_SRC

** Cython
#+BEGIN_SRC emacs-lisp
  (use-package cython-mode
    :straight t)
#+END_SRC

** Rust

#+BEGIN_SRC emacs-lisp
  (use-package rust-mode
    :straight t)
#+END_SRC

** Go

#+BEGIN_SRC emacs-lisp
  (use-package go-mode
    :straight t)
#+END_SRC

** Bazel

#+BEGIN_SRC emacs-lisp
  (use-package bazel-mode
    :straight
    (emacs-bazel-mode
     :host github
     :repo "bazelbuild/emacs-bazel-mode")
    :mode ("'BUILD'" "'WORKSPACE'" "\\.bzl\\'")
    :custom (
             (bazel-mode-buildifier-before-save t)
             (bazel-mode-buildifier-command "~/go/bin/buildifier"))
    )
#+END_SRC

** Markdown

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :straight t
    :commands (markdown-mode gfm-mode)
    :mode (("README\\.md\\'" . gfm-mode)
           ("\\.md\\'" . markdown-mode)
           ("\\.markdown\\'" . markdown-mode))
    :init (setq markdown-command "multimarkdown"
                markdown-header-scaling t
                markdown-hide-urls t
                markdown-marginalize-headers nil
                markdown-marginalize-headers-margin-width 4
                markdown-fontify-code-blocks-natively t)
    :hook
    (('markdown-mode .'variable-pitch-mode)
     ('markdown-mode . 'visual-line-mode)))
#+END_SRC

** Terraform
Trying out terraform for managing AWS stuff.

#+BEGIN_SRC emacs-lisp
  (use-package terraform-mode
    :straight t
    :hook ('terraform-mode-hook . #'terraform-format-on-save-mode))

  (use-package company-terraform
    :straight t
    :config
    (company-terraform-init))

  (add-to-list 'eglot-server-programs '(terraform-mode . ("tflint" "--langserver")))

  (flycheck-define-checker terraform-validate
                           "A Terraform syntax checker with `terraform validate.
            See URL `https://www.terraform.io/docs/commands/validate.html'."
                           :command ("terraform" "validate" "-no-color")
                           :standard-input t
                           :error-patterns
                           ((error line-start "Error: " (one-or-more not-newline)
                                   "\n\n  on " (file-name) " line " line ", " (one-or-more not-newline) "\n"
                                   (one-or-more not-newline) "\n\n"
                                   (message (one-or-more (and (one-or-more (not (any ?\n))) ?\n)))
                                   line-end))
                           :next-checkers ((warning . terraform-tflint))
                           :modes terraform-mode)

  (add-to-list 'flycheck-checkers 'terraform-validate)
#+END_SRC

** Dockerfile

#+BEGIN_SRC emacs-lisp
  (use-package dockerfile-mode :straight t)
#+END_SRC

** Nix

#+BEGIN_SRC emacs-lisp
  (use-package nix-mode
    :straight t
    :mode ("\\.nix\\'" "\\.nix.in\\'"))

  (use-package nix-drv-mode
    :mode "\\.drv\\'")

  (use-package nix-shell
    :commands (nix-shell-unpack nix-shell-configure nix-shell-build))

  (use-package nix-repl
    :commands (nix-repl))
#+END_SRC

* Private.el
I'd like to keep a few settings private, so we load a =private.el= if it
exists after the init-file has loaded.

#+BEGIN_SRC emacs-lisp
  (let ((private-file (concat user-emacs-directory "private.el")))
    (when (file-exists-p private-file)
      (load-file private-file)))
#+END_SRC

* Startup
Launch a server if not currently running, default to showing org daily agenda

#+BEGIN_SRC emacs-lisp
  (setq server-socket-dir "~/.emacs.d/server")
  (server-start)
  (org-agenda nil "d")
  (delete-other-windows)
#+END_SRC

* License

My Emacs configurations written in Org mode.

Copyright (c) 2019 Matthew Jones

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
